# V8 Exploitation Research Guide for GCP Dataform

## Executive Summary

GCP Dataform runs a V8 13.1 (Chrome 131, November 2024) JavaScript sandbox during SQLX compilation. This document provides instructions for a V8 exploitation specialist to fingerprint the exact version and develop exploits for sandbox escape.

**Key Finding:** All exploitation primitives are available (8/8 score). Three CVEs affect Chrome 131 with public disclosures but no public PoCs.

---

## Environment Overview

### Execution Model
```
┌─────────────────────────────────────────────────────────────┐
│                    GCP Dataform Pipeline                     │
├─────────────────────────────────────────────────────────────┤
│  1. Git Clone    → Repository fetched from GitHub/GitLab    │
│  2. npm ci       → Dependencies installed (--ignore-scripts)│
│  3. V8 Sandbox   → SQLX JavaScript blocks executed          │
│  4. BigQuery     → Compiled SQL executed                    │
└─────────────────────────────────────────────────────────────┘
```

**Attack Surface:** Phase 3 (V8 Sandbox) - JavaScript in `js { }` blocks runs during compilation with:
- No Node.js APIs (fs, child_process, net blocked)
- `restricted_fs` for limited file reading (workspace only)
- Full V8 JavaScript engine capabilities
- WASM support enabled
- SharedArrayBuffer enabled

### Confirmed V8 Version: 13.1 (Chrome 131)

Evidence from feature detection:
```
V8 12.5: Float16Array ✓
V8 12.6: Promise.try ✓
V8 12.7: Set.symmetricDifference ✓
V8 12.9: Object.groupBy, Map.groupBy ✓
V8 13.0: Temporal ✗ (not present)
V8 13.1: Symbol.dispose, Symbol.asyncDispose ✓
V8 13.2: Symbol.metadata ✗ (not present)

Conclusion: V8 13.1 (Chrome 131, November 2024)
```

---

## Dataform Interaction Commands

### Project Configuration
```bash
PROJECT_ID="shir-research-3"
LOCATION="us-central1"
REPO="dataform-poc-test"
```

### Trigger Compilation
```bash
# Get access token
TOKEN=$(gcloud auth print-access-token)

# Create compilation result (this executes JS code)
curl -s -X POST \
  "https://dataform.googleapis.com/v1beta1/projects/${PROJECT_ID}/locations/${LOCATION}/repositories/${REPO}/compilationResults" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"gitCommitish": "main"}'
```

### Check Compilation Status
```bash
COMP_ID="<compilation-id-from-above>"

curl -s \
  "https://dataform.googleapis.com/v1beta1/projects/${PROJECT_ID}/locations/${LOCATION}/repositories/${REPO}/compilationResults/${COMP_ID}" \
  -H "Authorization: Bearer $TOKEN"
```

### Run Workflow (Execute SQL in BigQuery)
```bash
curl -s -X POST \
  "https://dataform.googleapis.com/v1beta1/projects/${PROJECT_ID}/locations/${LOCATION}/repositories/${REPO}/workflowInvocations" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "compilationResult": "projects/'${PROJECT_ID}'/locations/'${LOCATION}'/repositories/'${REPO}'/compilationResults/'${COMP_ID}'",
    "invocationConfig": {
      "includedTargets": [{"database": "your-gcp-project", "schema": "dataform_poc", "name": "TARGET_NAME"}]
    }
  }'
```

### Local Compilation (for testing)
```bash
cd /Users/nirohfeld/work/jgit/poc/dataform
npx @dataform/cli@2.9.0 compile --json 2>&1 | jq '.tables[] | select(.target.name == "TARGET_NAME") | .query'
```

### Git Push to Trigger Remote Compilation
```bash
git add definitions/YOUR_FILE.sqlx
git commit -m "Test message"
git push origin main
# Then trigger compilation via API
```

---

## SQLX File Format

Create files in `definitions/` with `.sqlx` extension:

```javascript
config { type: "view", name: "your_view_name" }

js {
  // JavaScript code runs during COMPILATION (not BigQuery execution)
  let results = {};

  // Your V8 exploitation code here
  results.test = "value";

  // Results must be JSON-serializable
}

SELECT '${JSON.stringify(results)}' as output
```

**Critical Notes:**
- JS runs at compile time, not runtime
- Results are embedded in the compiled SQL string
- Use `try/catch` liberally - uncaught exceptions crash compilation
- Avoid `WebAssembly.compile()` with invalid bytes - use `WebAssembly.validate()` instead
- `eval()` is available
- `Proxy`, `Reflect`, `Symbol` all available

---

## Vulnerability Probe Results

### Available Primitives (8/8 Score)

| Primitive | Status | Notes |
|-----------|--------|-------|
| WebAssembly | ✓ | Full support including Exception, Tag |
| SharedArrayBuffer | ✓ | With growable buffers |
| Atomics.waitAsync | ✓ | Race condition primitive |
| ArrayBuffer.transfer | ✓ | UAF primitive |
| Resizable ArrayBuffer | ✓ | Memory manipulation |
| JIT Compilation | ✓ | 1ms hot loop, deopt works |
| Symbol.species | ✓ | Type confusion vector |
| Proxy traps | ✓ | getPrototypeOf, etc. |

### Blocked Features

| Feature | Status | Notes |
|---------|--------|-------|
| %NativeSyntax | ✗ | "Unexpected token '%'" |
| Node.js APIs | ✗ | fs, child_process, net unavailable |
| require() | Limited | Only workspace files + node_modules |

---

## Target CVEs for Chrome 131 / V8 13.1

### CVE-2024-12053
- **Fixed in:** Chrome 131.0.6778.108
- **Type:** Type confusion in V8
- **Chromium Bug:** https://issues.chromium.org/issues/378936316
- **Notes:** First security fix for Chrome 131

### CVE-2024-12692
- **Fixed in:** Chrome 131.0.6778.204
- **Type:** Type confusion in V8
- **Bounty:** $55,000 (indicates high severity)
- **Chromium Bug:** https://issues.chromium.org/issues/382123319
- **Notes:** High-value target, likely has good exploitation primitives

### CVE-2025-0291
- **Fixed in:** Chrome 131.0.6778.264
- **Type:** Type confusion in V8
- **Chromium Bug:** https://issues.chromium.org/issues/385574063
- **Notes:** Most recent, may still be unpatched in Dataform

### Exploitation Strategy
If Dataform runs Chrome 131.0.6778.x where x < 264, at least one CVE is exploitable.

---

## Version Fingerprinting Tasks

### Task 1: Determine Exact Chrome Patch Level

The V8 version alone doesn't tell us the exact patch level. Additional fingerprinting needed:

```javascript
js {
  let fingerprint = {};

  // Check for specific bug fixes that indicate patch level
  // CVE-2024-12053 fixed behavior changes
  // CVE-2024-12692 fixed behavior changes
  // CVE-2025-0291 fixed behavior changes

  // TODO: Research specific behavioral differences between patch levels
}
```

### Task 2: Check Error Message Differences

Different Chrome versions may have different error messages:

```javascript
js {
  let errors = {};
  try {
    // Trigger specific errors that may reveal version info
    eval('class C { #x; static { C.#x } }');
  } catch(e) {
    errors.privateField = e.message;
  }
  // Compare against known Chrome version error messages
}
```

### Task 3: WASM Feature Detection

```javascript
js {
  let wasm = {};

  // Check for WASM GC (may indicate newer versions)
  // Check for WASM exception handling details
  // Check for WASM SIMD specifics

  // These can narrow down the exact V8 version
}
```

---

## Exploitation Development Tasks

### Task 1: Type Confusion Primitive

Develop a type confusion primitive using the available features:

```javascript
js {
  // CVE-2024-12692 pattern: SharedArrayBuffer type aliasing
  const sab = new SharedArrayBuffer(16);
  const i32 = new Int32Array(sab);
  const f64 = new Float64Array(sab);

  // Type confusion: write as int, read as float
  i32[0] = 0x41414141;
  i32[1] = 0x41414141;

  // This gives us a float that represents those int bits
  // Can be used to leak/forge pointers
}
```

### Task 2: JIT Spray / Type Confusion via Optimization

```javascript
js {
  function vulnerable(obj) {
    return obj.x + obj.y;
  }

  // Warm up with consistent types (triggers JIT)
  for (let i = 0; i < 100000; i++) {
    vulnerable({x: i, y: i});
  }

  // Type confusion: JIT assumes numbers, but we pass different types
  vulnerable({x: {}, y: []});
}
```

### Task 3: WASM Sandbox Escape

Research WASM-based sandbox escape techniques:
- WASM memory corruption
- WASM type confusion
- WASM → JS boundary exploitation

---

## Files in This Repository

| File | Purpose |
|------|---------|
| `definitions/v8_vuln_probe.sqlx` | Main vulnerability primitive testing |
| `definitions/v8_latest_probe.sqlx` | V8 version detection (12.5-14.x features) |
| `definitions/v8_version_probe.sqlx` | Basic V8 feature probing |
| `definitions/v8_exact_version.sqlx` | Detailed version detection methods |
| `definitions/v8_version_exact.sqlx` | Additional version fingerprinting |
| `package.json` | npm dependencies (@dataform/core 2.9.0) |
| `dataform.json` | Dataform project configuration |

---

## Success Criteria

### For Fingerprinting Agent
1. Determine exact Chrome patch level (131.0.6778.XXX)
2. Confirm which CVEs are applicable
3. Identify behavioral differences that indicate patch status

### For Exploitation Agent
1. Develop working type confusion primitive
2. Achieve arbitrary read/write in V8 heap
3. Bypass V8 sandbox (if present)
4. Achieve code execution outside sandbox

### Ultimate Goal
Execute arbitrary code on the Dataform compilation server with access to:
- GCP metadata server (169.254.169.254)
- Service account credentials
- Network access to internal GCP services

---

## References

- V8 Blog: https://v8.dev/blog
- Chrome Releases: https://chromereleases.googleblog.com/
- V8 Source: https://chromium.googlesource.com/v8/v8/
- Chromium Issue Tracker: https://issues.chromium.org/
- V8CTF: https://github.com/nicholascw/v8ctf (exploit techniques)

---

## Contact / Continuation

This research was conducted as part of GCP Dataform security testing. For questions or to continue this session, reference:
- Repository: `nirohfeld/dataform-poc`
- Branch: `main`
- GCP Project: `shir-research-3`
- Dataform Repository: `dataform-poc-test`
- Location: `us-central1`

Last updated: 2025-12-18
