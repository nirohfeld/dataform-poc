config { type: "view", name: "v8_jit_spray_probe" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "JIT spray and code generation probes for potential gadget hunting"
  };

  // =============================================================================
  // TEST 1: Float64Array Type Punning
  // Use ArrayBuffer aliasing to convert between float and int representations
  // =============================================================================
  results.test1_typePunning = {};
  try {
    const buf = new ArrayBuffer(8);
    const f64 = new Float64Array(buf);
    const u32 = new Uint32Array(buf);
    const u8 = new Uint8Array(buf);

    // IEEE 754 double encoding tests
    f64[0] = 1.1;
    const onePointOneAsInts = [u32[0], u32[1]];

    // Craft specific bit patterns
    u32[0] = 0x41414141;
    u32[1] = 0x42424242;
    const craftedAsFloat = f64[0];

    // Test pointer-sized values (for potential addrof/fakeobj)
    u32[0] = 0x00000000;
    u32[1] = 0x00100000;  // Tagged pointer pattern
    const taggedAsFloat = f64[0];

    results.test1_typePunning = {
      status: "completed",
      onePointOneHigh: onePointOneAsInts[1].toString(16),
      onePointOneLow: onePointOneAsInts[0].toString(16),
      craftedFloat: craftedAsFloat,
      taggedFloat: taggedAsFloat
    };
  } catch(e) {
    results.test1_typePunning = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Array Element Kind Transitions
  // Force transitions between PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS
  // =============================================================================
  results.test2_elementsKind = {};
  try {
    function accessElement(arr, idx) {
      return arr[idx];
    }

    // Phase 1: PACKED_SMI_ELEMENTS
    const smiArr = [1, 2, 3, 4, 5];
    for (let i = 0; i < 50000; i++) {
      accessElement(smiArr, i % 5);
    }

    // Phase 2: Transition to PACKED_DOUBLE_ELEMENTS
    smiArr[0] = 1.5;
    for (let i = 0; i < 50000; i++) {
      accessElement(smiArr, i % 5);
    }

    // Phase 3: Transition to PACKED_ELEMENTS
    smiArr[1] = { x: 1 };
    for (let i = 0; i < 50000; i++) {
      accessElement(smiArr, i % 5);
    }

    const finalRead = accessElement(smiArr, 0);

    results.test2_elementsKind = {
      status: "completed",
      element0: smiArr[0],
      element1Type: typeof smiArr[1],
      element2: smiArr[2],
      finalRead: finalRead
    };
  } catch(e) {
    results.test2_elementsKind = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Arguments Object Materialization
  // Test if optimized code properly handles arguments object
  // =============================================================================
  results.test3_arguments = {};
  try {
    function useArguments() {
      // This should force arguments object materialization
      return arguments[0] + arguments[1] + arguments.length;
    }

    function wrapper(a, b) {
      return useArguments(a, b);
    }

    // Warm up
    for (let i = 0; i < 100000; i++) {
      wrapper(i, i + 1);
    }

    const normalResult = wrapper(10, 20);
    const extraArgsResult = wrapper(10, 20, 30, 40);  // Extra arguments

    // Test with apply
    const applyResult = useArguments.apply(null, [1, 2, 3, 4, 5]);

    results.test3_arguments = {
      status: "completed",
      normalResult: normalResult,
      extraArgsResult: extraArgsResult,
      applyResult: applyResult
    };
  } catch(e) {
    results.test3_arguments = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Generator/Iterator Confusion
  // =============================================================================
  results.test4_generators = {};
  try {
    function* numberGenerator() {
      let i = 0;
      while (true) {
        yield i++;
      }
    }

    function consumeGenerator(gen, count) {
      let sum = 0;
      for (let i = 0; i < count; i++) {
        sum += gen.next().value;
      }
      return sum;
    }

    // Warm up
    for (let i = 0; i < 1000; i++) {
      const gen = numberGenerator();
      consumeGenerator(gen, 100);
    }

    // Test with manual next() calls interleaved
    const gen = numberGenerator();
    let results_arr = [];
    for (let i = 0; i < 5; i++) {
      results_arr.push(gen.next().value);
    }

    // Modify generator prototype during iteration
    const originalNext = gen.next;

    results.test4_generators = {
      status: "completed",
      firstFive: results_arr,
      genDone: gen.next().done
    };
  } catch(e) {
    results.test4_generators = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: WeakRef and FinalizationRegistry
  // Test if GC can be abused for UAF-like behavior
  // =============================================================================
  results.test5_weakRef = {};
  try {
    let cleanupCalled = 0;
    const registry = new FinalizationRegistry((heldValue) => {
      cleanupCalled++;
    });

    let weakRefs = [];
    let strongRefs = [];

    // Create objects and weak references
    for (let i = 0; i < 100; i++) {
      const obj = { value: i, data: new Array(1000).fill(i) };
      weakRefs.push(new WeakRef(obj));
      if (i % 2 === 0) {
        strongRefs.push(obj);  // Keep every other one alive
      }
      registry.register(obj, i);
    }

    // Try to trigger GC by allocating
    for (let i = 0; i < 10000; i++) {
      const temp = new Array(1000).fill(i);
    }

    // Check which refs are still alive
    let alive = 0;
    let dead = 0;
    for (const ref of weakRefs) {
      if (ref.deref() !== undefined) {
        alive++;
      } else {
        dead++;
      }
    }

    results.test5_weakRef = {
      status: "completed",
      totalRefs: weakRefs.length,
      alive: alive,
      dead: dead,
      strongCount: strongRefs.length,
      cleanupCalled: cleanupCalled
    };
  } catch(e) {
    results.test5_weakRef = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Symbol.toStringTag Override
  // =============================================================================
  results.test6_toStringTag = {};
  try {
    function checkType(obj) {
      return Object.prototype.toString.call(obj);
    }

    // Warm up with normal objects
    for (let i = 0; i < 50000; i++) {
      checkType({});
      checkType([]);
      checkType(new Map());
    }

    // Create object with fake tag
    const fakeArray = {
      [Symbol.toStringTag]: "Array",
      length: 10,
      0: "a", 1: "b"
    };

    const fakeArrayBuffer = {
      [Symbol.toStringTag]: "ArrayBuffer",
      byteLength: 1024
    };

    results.test6_toStringTag = {
      status: "completed",
      fakeArrayType: checkType(fakeArray),
      fakeABType: checkType(fakeArrayBuffer),
      realArrayType: checkType([]),
      realABType: checkType(new ArrayBuffer(8))
    };
  } catch(e) {
    results.test6_toStringTag = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: BigInt Arithmetic Overflow
  // =============================================================================
  results.test7_bigInt = {};
  try {
    function bigIntOp(a, b) {
      return a * b;
    }

    // Warm up with small BigInts
    for (let i = 0; i < 50000; i++) {
      bigIntOp(BigInt(i), BigInt(i + 1));
    }

    // Test with large values
    const large1 = BigInt("0x" + "ff".repeat(32));
    const large2 = BigInt("0x" + "ee".repeat(32));
    const largeResult = bigIntOp(large1, large2);

    // Test mixed operations that might confuse
    const mixedResult = BigInt(Number.MAX_SAFE_INTEGER) + 1n;

    results.test7_bigInt = {
      status: "completed",
      largeResultLength: largeResult.toString(16).length,
      mixedResult: mixedResult.toString(),
      maxSafeInt: BigInt(Number.MAX_SAFE_INTEGER).toString()
    };
  } catch(e) {
    results.test7_bigInt = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Async Function State Machine
  // =============================================================================
  results.test8_asyncState = {};
  try {
    let stateLog = [];

    async function asyncStateMachine(input) {
      stateLog.push("start:" + input);
      const result1 = await Promise.resolve(input * 2);
      stateLog.push("after1:" + result1);
      const result2 = await Promise.resolve(result1 * 2);
      stateLog.push("after2:" + result2);
      return result2;
    }

    // Run synchronously as much as possible
    const promises = [];
    for (let i = 0; i < 100; i++) {
      promises.push(asyncStateMachine(i));
    }

    // Check state log for any anomalies
    const stateLogSnapshot = stateLog.slice(0, 20);

    results.test8_asyncState = {
      status: "completed",
      statesLogged: stateLog.length,
      firstStates: stateLogSnapshot,
      promisesCreated: promises.length
    };
  } catch(e) {
    results.test8_asyncState = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length
  };
}

SELECT '${JSON.stringify(results, null, 2)}' as jit_spray_probe
