config { type: "view", name: "dataform_internals_probe" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Deep dive into dataform global object and internal structures"
  };

  // Helper to safely serialize objects
  function safeSerialize(obj, depth = 3, seen = new WeakSet()) {
    if (depth <= 0) return "[max depth]";
    if (obj === null) return null;
    if (obj === undefined) return undefined;

    const type = typeof obj;
    if (type !== 'object' && type !== 'function') return obj;

    if (type === 'function') {
      return {
        _type: 'function',
        name: obj.name || 'anonymous',
        length: obj.length,
        toString: obj.toString().substring(0, 200)
      };
    }

    if (seen.has(obj)) return "[circular]";
    seen.add(obj);

    if (Array.isArray(obj)) {
      return obj.slice(0, 10).map(item => safeSerialize(item, depth - 1, seen));
    }

    const result = {};
    for (const key of Object.keys(obj).slice(0, 20)) {
      try {
        result[key] = safeSerialize(obj[key], depth - 1, seen);
      } catch(e) {
        result[key] = "[error: " + e.message.substring(0, 50) + "]";
      }
    }
    return result;
  }

  // =============================================================================
  // TEST 1: Dataform Global Object Deep Inspection
  // =============================================================================
  results.test1_dataformGlobal = {};
  try {
    if (typeof dataform === 'undefined') {
      results.test1_dataformGlobal = { error: "dataform is undefined" };
    } else {
      const dfInfo = {
        type: typeof dataform,
        keys: Object.keys(dataform),
        prototype: Object.getPrototypeOf(dataform)?.constructor?.name
      };

      // Inspect each property
      for (const key of Object.keys(dataform)) {
        dfInfo[key] = {
          type: typeof dataform[key],
          isArray: Array.isArray(dataform[key]),
          length: dataform[key]?.length,
          keys: dataform[key] && typeof dataform[key] === 'object' ?
            Object.keys(dataform[key]).slice(0, 10) : null
        };
      }

      results.test1_dataformGlobal = {
        status: "completed",
        dfInfo
      };
    }
  } catch(e) {
    results.test1_dataformGlobal = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Project Config Deep Dive
  // =============================================================================
  results.test2_projectConfig = {};
  try {
    if (typeof dataform === 'undefined' || !dataform.projectConfig) {
      results.test2_projectConfig = { error: "projectConfig not available" };
    } else {
      const config = dataform.projectConfig;

      results.test2_projectConfig = {
        status: "completed",
        configKeys: Object.keys(config),
        config: safeSerialize(config, 4)
      };
    }
  } catch(e) {
    results.test2_projectConfig = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Canonical Project Config
  // =============================================================================
  results.test3_canonicalConfig = {};
  try {
    if (typeof dataform === 'undefined' || !dataform.canonicalProjectConfig) {
      results.test3_canonicalConfig = { error: "canonicalProjectConfig not available" };
    } else {
      const config = dataform.canonicalProjectConfig;

      results.test3_canonicalConfig = {
        status: "completed",
        configKeys: Object.keys(config),
        config: safeSerialize(config, 4)
      };
    }
  } catch(e) {
    results.test3_canonicalConfig = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Actions Array Inspection
  // =============================================================================
  results.test4_actions = {};
  try {
    if (typeof dataform === 'undefined' || !dataform.actions) {
      results.test4_actions = { error: "actions not available" };
    } else {
      const actions = dataform.actions;

      results.test4_actions = {
        status: "completed",
        count: actions.length,
        types: [...new Set(actions.map(a => a.type || a.constructor?.name))],
        sampleActions: actions.slice(0, 5).map(a => ({
          type: a.type,
          name: a.name,
          target: a.target,
          keys: Object.keys(a).slice(0, 10)
        }))
      };
    }
  } catch(e) {
    results.test4_actions = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Session Object from Dataform Core
  // =============================================================================
  results.test5_session = {};
  try {
    const dfCore = require('@dataform/core');

    if (!dfCore.session) {
      results.test5_session = { error: "session not in @dataform/core" };
    } else {
      const session = dfCore.session;

      results.test5_session = {
        status: "completed",
        sessionType: typeof session,
        sessionKeys: Object.keys(session),
        session: safeSerialize(session, 3)
      };
    }
  } catch(e) {
    results.test5_session = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Global Functions Inspection
  // =============================================================================
  results.test6_globalFuncs = {};
  try {
    const funcs = {};

    const funcNames = [
      'publish', 'ref', 'resolve', 'declare', 'assert', 'operate',
      'test', 'config', 'type', 'preOps', 'postOps', 'where',
      'incremental', 'schema', 'database', 'columns', 'description'
    ];

    for (const name of funcNames) {
      if (typeof global[name] === 'function') {
        funcs[name] = {
          available: true,
          length: global[name].length,
          toString: global[name].toString().substring(0, 300)
        };
      } else if (typeof globalThis[name] === 'function') {
        funcs[name] = {
          available: true,
          source: 'globalThis',
          length: globalThis[name].length
        };
      }
    }

    results.test6_globalFuncs = {
      status: "completed",
      availableFunctions: Object.keys(funcs),
      funcs
    };
  } catch(e) {
    results.test6_globalFuncs = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: rootDir and File Access
  // =============================================================================
  results.test7_rootDir = {};
  try {
    if (typeof dataform === 'undefined' || !dataform.rootDir) {
      results.test7_rootDir = { error: "rootDir not available" };
    } else {
      const rootDir = dataform.rootDir;

      // Try to access files relative to rootDir
      let files = null;
      try {
        const fs = require('fs');
        files = fs.readdirSync(rootDir);
      } catch(e) {
        files = { error: e.message.substring(0, 100) };
      }

      results.test7_rootDir = {
        status: "completed",
        rootDir,
        files
      };
    }
  } catch(e) {
    results.test7_rootDir = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Indexed Actions Map
  // =============================================================================
  results.test8_indexedActions = {};
  try {
    if (typeof dataform === 'undefined' || !dataform.indexedActions) {
      results.test8_indexedActions = { error: "indexedActions not available" };
    } else {
      const indexed = dataform.indexedActions;

      results.test8_indexedActions = {
        status: "completed",
        type: typeof indexed,
        isMap: indexed instanceof Map,
        keys: indexed instanceof Map ?
          [...indexed.keys()].slice(0, 10) :
          Object.keys(indexed).slice(0, 10),
        size: indexed instanceof Map ? indexed.size : Object.keys(indexed).length
      };
    }
  } catch(e) {
    results.test8_indexedActions = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: Graph Errors (might contain sensitive info)
  // =============================================================================
  results.test9_graphErrors = {};
  try {
    if (typeof dataform === 'undefined') {
      results.test9_graphErrors = { error: "dataform is undefined" };
    } else {
      const errors = dataform.graphErrors;

      results.test9_graphErrors = {
        status: "completed",
        type: typeof errors,
        isArray: Array.isArray(errors),
        count: errors?.length || 0,
        errors: Array.isArray(errors) ? errors.slice(0, 5) : safeSerialize(errors, 2)
      };
    }
  } catch(e) {
    results.test9_graphErrors = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Look for Credentials in All Objects
  // =============================================================================
  results.test10_credentialSearch = {};
  try {
    const credPatterns = ['key', 'secret', 'token', 'password', 'credential', 'auth', 'private'];
    const found = [];

    // Search in dataform object
    function searchObj(obj, path, depth = 0) {
      if (depth > 4 || !obj || typeof obj !== 'object') return;

      for (const key of Object.keys(obj)) {
        const lowerKey = key.toLowerCase();
        const newPath = path + '.' + key;

        for (const pattern of credPatterns) {
          if (lowerKey.includes(pattern)) {
            found.push({
              path: newPath,
              key,
              type: typeof obj[key],
              value: typeof obj[key] === 'string' ?
                obj[key].substring(0, 50) :
                (typeof obj[key])
            });
          }
        }

        if (typeof obj[key] === 'object' && obj[key] !== null) {
          searchObj(obj[key], newPath, depth + 1);
        }
      }
    }

    if (typeof dataform !== 'undefined') {
      searchObj(dataform, 'dataform');
    }

    // Search in require.cache
    if (typeof require !== 'undefined' && require.cache) {
      for (const modPath of Object.keys(require.cache).slice(0, 20)) {
        const mod = require.cache[modPath];
        if (mod && mod.exports) {
          searchObj(mod.exports, 'cache:' + modPath.split('/').pop());
        }
      }
    }

    results.test10_credentialSearch = {
      status: "completed",
      credentialsFound: found.length,
      found: found.slice(0, 20)
    };
  } catch(e) {
    results.test10_credentialSearch = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 10,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check findings
  if (results.test10_credentialSearch && results.test10_credentialSearch.credentialsFound > 0) {
    results.summary.criticalFindings.push(
      "CREDENTIAL-LIKE KEYS FOUND: " + results.test10_credentialSearch.credentialsFound
    );
  }

  if (results.test2_projectConfig && results.test2_projectConfig.status === "completed") {
    const cfg = results.test2_projectConfig.config || {};
    if (cfg.defaultDatabase || cfg.defaultProject) {
      results.summary.criticalFindings.push(
        "Project config accessible with database/project info"
      );
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as dataform_internals_probe
