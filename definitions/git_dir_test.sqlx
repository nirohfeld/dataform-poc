-- .git Directory Access Test
-- Tests if we can read/write to .git/ for code execution via hooks/config

config {
  type: "view",
  name: "git_dir_test"
}

js {
  let results = [];

  // Test 1: Check if .git exists
  try {
    const exists = restricted_fs.exists(".git");
    const isDir = restricted_fs.isDirectory(".git");
    results.push("1_git_exists: exists=" + exists + ", isDir=" + isDir);
  } catch(e) {
    results.push("1_git_exists: FAIL - " + e.message);
  }

  // Test 2: Try to read .git/config
  try {
    const content = restricted_fs.readFile(".git/config");
    results.push("2_git_config: SUCCESS len=" + content.length + " - " + content.substring(0, 200));
  } catch(e) {
    results.push("2_git_config: FAIL - " + e.message.substring(0, 100));
  }

  // Test 3: Try to read .git/HEAD
  try {
    const content = restricted_fs.readFile(".git/HEAD");
    results.push("3_git_HEAD: SUCCESS - " + content.substring(0, 100));
  } catch(e) {
    results.push("3_git_HEAD: FAIL - " + e.message.substring(0, 100));
  }

  // Test 4: Try to read .git/hooks/
  try {
    const exists = restricted_fs.exists(".git/hooks");
    const isDir = restricted_fs.isDirectory(".git/hooks");
    results.push("4_git_hooks: exists=" + exists + ", isDir=" + isDir);
  } catch(e) {
    results.push("4_git_hooks: FAIL - " + e.message.substring(0, 100));
  }

  // Test 5: Try various .git paths
  const gitPaths = [
    ".git/objects",
    ".git/refs",
    ".git/info/exclude",
    ".git/description",
    ".git/packed-refs",
    "../.git/config",
    "definitions/../.git/config"
  ];
  for (const p of gitPaths) {
    try {
      if (restricted_fs.exists(p)) {
        const isDir = restricted_fs.isDirectory(p);
        if (!isDir) {
          const content = restricted_fs.readFile(p);
          results.push("5_" + p.replace(/[/.]/g, "_") + ": EXISTS len=" + content.length);
        } else {
          results.push("5_" + p.replace(/[/.]/g, "_") + ": EXISTS isDir=true");
        }
      } else {
        results.push("5_" + p.replace(/[/.]/g, "_") + ": NOT_EXISTS");
      }
    } catch(e) {
      results.push("5_" + p.replace(/[/.]/g, "_") + ": FAIL - " + e.message.substring(0, 50));
    }
  }

  // Test 6: Check available filesystem methods (might include write)
  try {
    const fsMethods = Object.keys(restricted_fs);
    results.push("6_fs_methods: " + fsMethods.join(","));
    // Check for write methods
    const writeMethods = fsMethods.filter(m =>
      m.includes("write") || m.includes("Write") ||
      m.includes("create") || m.includes("Create") ||
      m.includes("append") || m.includes("mkdir")
    );
    results.push("6_write_methods: " + (writeMethods.length ? writeMethods.join(",") : "NONE"));
  } catch(e) {
    results.push("6_fs_methods: FAIL - " + e.message);
  }

  // Test 7: Check vm object for file operations
  try {
    const vmMethods = Object.keys(vm || {});
    results.push("7_vm_methods: " + vmMethods.join(","));
  } catch(e) {
    results.push("7_vm_methods: FAIL - " + e.message);
  }

  // Test 8: Try to access __dirname and __filename for path info
  try {
    results.push("8_dirname: " + __dirname);
    results.push("8_filename: " + __filename);
  } catch(e) {
    results.push("8_paths: FAIL - " + e.message);
  }

  // Test 9: Check if we can access parent directories
  try {
    const parent = restricted_fs.exists("..");
    const parentDir = restricted_fs.isDirectory("..");
    results.push("9_parent: exists=" + parent + ", isDir=" + parentDir);
    const root = restricted_fs.exists("/");
    results.push("9_root: exists=" + root);
  } catch(e) {
    results.push("9_parent: FAIL - " + e.message);
  }

  // Test 10: Look for any global with fs/file in name
  try {
    let fsGlobals = [];
    for (const key of Object.keys(globalThis)) {
      if (key.toLowerCase().includes("fs") || key.toLowerCase().includes("file")) {
        fsGlobals.push(key);
      }
    }
    results.push("10_fs_globals: " + (fsGlobals.length ? fsGlobals.join(",") : "NONE"));
  } catch(e) {
    results.push("10_fs_globals: FAIL - " + e.message);
  }
}

SELECT
  '${JSON.stringify(results)}' as git_dir_results
