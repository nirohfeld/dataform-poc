config { type: "view", name: "v8_maglev_variant_probe" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Testing Maglev type confusion patterns from CVE-2023-4069 and CVE-2024-4947"
  };

  // =============================================================================
  // TEST 1: CVE-2023-4069 Pattern - Reflect.construct with mismatched types
  // Original bug: BuildAllocateFastObject() doesn't verify constructor field
  // =============================================================================
  results.test1_reflectConstruct = {};
  try {
    class A {}
    var capturedNewTarget = null;

    class B extends A {
      constructor() {
        capturedNewTarget = new.target;
        super();
      }
    }

    // Natural warmup to trigger Maglev (no native syntax)
    for (let i = 0; i < 20000; i++) {
      Reflect.construct(B, [], B);
    }

    // Now test with Array as newTarget (mismatched)
    let x = Array;
    class C extends A {
      constructor() {
        x = new.target;
        super();
      }
    }

    for (let i = 0; i < 20000; i++) {
      Reflect.construct(C, [], x);
    }

    results.test1_reflectConstruct = {
      status: "completed",
      capturedType: typeof x,
      isArray: x === Array,
      prototypeCheck: x.prototype === Array.prototype
    };
  } catch(e) {
    results.test1_reflectConstruct = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Property store during optimization (CVE-2024-4947 variant)
  // Original bug: incorrect PropertyAccessInfo for module namespace objects
  // =============================================================================
  results.test2_propertyStore = {};
  try {
    // Create object with prototype chain
    const proto = { c: undefined };
    const target = Object.create(proto);

    function storeProperty(obj, val) {
      obj.c = val;
    }

    // Warmup with consistent types
    for (let i = 0; i < 20000; i++) {
      storeProperty(target, i);
    }

    // Now try with different object shapes
    const differentShape = { a: 1, b: 2, c: 3 };
    storeProperty(differentShape, 999);

    results.test2_propertyStore = {
      status: "completed",
      targetC: target.c,
      differentShapeC: differentShape.c
    };
  } catch(e) {
    results.test2_propertyStore = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Array length confusion via GC pressure
  // =============================================================================
  results.test3_arrayGC = {};
  try {
    const arrays = [];

    function createAndStore() {
      const arr = [1.1, 2.2, 3.3, 4.4];
      arrays.push(arr);
      return arr.length;
    }

    // Create many arrays to pressure GC
    for (let i = 0; i < 10000; i++) {
      createAndStore();
    }

    // Check if any array has unexpected length
    let anomalies = 0;
    for (const arr of arrays) {
      if (arr.length !== 4) anomalies++;
    }

    // Force some GC activity
    arrays.length = 0;
    for (let i = 0; i < 5000; i++) {
      createAndStore();
    }

    let anomalies2 = 0;
    for (const arr of arrays) {
      if (arr.length !== 4) anomalies2++;
    }

    results.test3_arrayGC = {
      status: "completed",
      firstPassAnomalies: anomalies,
      secondPassAnomalies: anomalies2,
      totalArrays: arrays.length
    };
  } catch(e) {
    results.test3_arrayGC = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Class inheritance with non-default constructors
  // =============================================================================
  results.test4_inheritance = {};
  try {
    class Parent {
      constructor() {
        this.parentProp = "parent";
      }
    }

    class Child extends Parent {
      constructor() {
        super();
        this.childProp = "child";
      }
    }

    function createInstances() {
      const instances = [];
      for (let i = 0; i < 100; i++) {
        instances.push(new Child());
      }
      return instances;
    }

    // Warmup
    for (let i = 0; i < 200; i++) {
      createInstances();
    }

    // Check for any property confusion
    const finalInstances = createInstances();
    let propertyAnomalies = 0;
    for (const inst of finalInstances) {
      if (inst.parentProp !== "parent" || inst.childProp !== "child") {
        propertyAnomalies++;
      }
    }

    results.test4_inheritance = {
      status: "completed",
      anomalies: propertyAnomalies,
      sampleHasParent: finalInstances[0].parentProp === "parent",
      sampleHasChild: finalInstances[0].childProp === "child"
    };
  } catch(e) {
    results.test4_inheritance = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Symbol.species manipulation during array operations
  // =============================================================================
  results.test5_species = {};
  try {
    let speciesCallCount = 0;
    let speciesConstructorCalled = false;

    class EvilArray extends Array {
      static get [Symbol.species]() {
        speciesCallCount++;
        return EvilArray;
      }
      constructor(...args) {
        super(...args);
        speciesConstructorCalled = true;
      }
    }

    function arrayOps(arr) {
      return arr.map(x => x * 2);
    }

    const evil = new EvilArray(1, 2, 3, 4, 5);

    // Warmup
    for (let i = 0; i < 10000; i++) {
      arrayOps(evil);
    }

    const beforeCount = speciesCallCount;
    const result = arrayOps(evil);

    results.test5_species = {
      status: "completed",
      speciesCallsBefore: beforeCount,
      speciesCallsAfter: speciesCallCount,
      resultIsEvilArray: result instanceof EvilArray,
      resultLength: result.length
    };
  } catch(e) {
    results.test5_species = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: TypedArray type confusion
  // =============================================================================
  results.test6_typedArray = {};
  try {
    const buffer = new ArrayBuffer(32);
    const int32View = new Int32Array(buffer);
    const float64View = new Float64Array(buffer);

    function writeRead(view, idx, val) {
      view[idx] = val;
      return view[idx];
    }

    // Warmup with int32
    for (let i = 0; i < 10000; i++) {
      writeRead(int32View, 0, i);
    }

    // Now switch to float64
    const floatResult = writeRead(float64View, 0, 3.14159);

    // Read back as int32
    const intResult = int32View[0];

    results.test6_typedArray = {
      status: "completed",
      floatWritten: 3.14159,
      floatRead: floatResult,
      intReadBack: intResult,
      bufferByteLength: buffer.byteLength
    };
  } catch(e) {
    results.test6_typedArray = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Proxy trap during optimized code
  // =============================================================================
  results.test7_proxy = {};
  try {
    let trapCount = 0;
    const target = { x: 1, y: 2 };
    const handler = {
      get(t, prop) {
        trapCount++;
        return t[prop];
      }
    };
    const proxy = new Proxy(target, handler);

    function accessProps(obj) {
      return obj.x + obj.y;
    }

    // Warmup with regular object
    for (let i = 0; i < 10000; i++) {
      accessProps(target);
    }

    const beforeTrap = trapCount;

    // Now use proxy
    for (let i = 0; i < 1000; i++) {
      accessProps(proxy);
    }

    results.test7_proxy = {
      status: "completed",
      trapCountBefore: beforeTrap,
      trapCountAfter: trapCount,
      trapsCalled: trapCount > beforeTrap
    };
  } catch(e) {
    results.test7_proxy = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 7,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    anyAnomalies:
      (results.test3_arrayGC.firstPassAnomalies > 0) ||
      (results.test3_arrayGC.secondPassAnomalies > 0) ||
      (results.test4_inheritance.anomalies > 0)
  };
}

SELECT '${JSON.stringify(results, null, 2)}' as maglev_probe
