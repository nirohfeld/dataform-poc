-- WebAssembly and Core Object Test
-- Tests if WASM can escape sandbox or if core object has exploitable methods

config {
  type: "view",
  name: "wasm_core_test"
}

js {
  let results = [];

  // Test 1: WebAssembly capabilities
  try {
    const wasmKeys = Object.keys(WebAssembly);
    results.push("1_WASM_keys: " + wasmKeys.join(","));
  } catch(e) {
    results.push("1_WASM_keys: FAIL - " + e.message);
  }

  // Test 2: Can we instantiate WASM?
  try {
    // Simple WASM module that returns 42
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7f,
      0x03, 0x02, 0x01, 0x00,
      0x07, 0x08, 0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00,
      0x0a, 0x06, 0x01, 0x04, 0x00, 0x41, 0x2a, 0x0b
    ]);
    const wasmModule = new WebAssembly.Module(wasmBytes);
    const wasmInstance = new WebAssembly.Instance(wasmModule);
    results.push("2_WASM_instance: SUCCESS, main()=" + wasmInstance.exports.main());
  } catch(e) {
    results.push("2_WASM_instance: FAIL - " + e.message);
  }

  // Test 3: core object methods
  try {
    const coreKeys = Object.keys(core);
    results.push("3_Core_keys: " + coreKeys.join(","));
  } catch(e) {
    results.push("3_Core_keys: FAIL - " + e.message);
  }

  // Test 4: core.session
  try {
    const sessionKeys = Object.keys(core.session || {});
    results.push("4_Session_keys: " + sessionKeys.slice(0, 15).join(","));
  } catch(e) {
    results.push("4_Session_keys: FAIL - " + e.message);
  }

  // Test 5: core.compiler
  try {
    const compilerType = typeof core.compiler;
    results.push("5_Compiler_type: " + compilerType);
    if (compilerType === 'function') {
      results.push("5_Compiler_src: " + core.compiler.toString().substring(0, 100));
    }
  } catch(e) {
    results.push("5_Compiler: FAIL - " + e.message);
  }

  // Test 6: core.adapters
  try {
    const adaptersKeys = Object.keys(core.adapters || {});
    results.push("6_Adapters_keys: " + adaptersKeys.join(","));
  } catch(e) {
    results.push("6_Adapters: FAIL - " + e.message);
  }

  // Test 7: Check for any global with 'process' in prototype chain
  try {
    let found = [];
    const checkObj = (obj, name, depth) => {
      if (depth > 3 || !obj) return;
      try {
        if (obj.process) found.push(name + ".process");
        if (obj.constructor && obj.constructor.name === 'process') found.push(name + ".ctor");
      } catch(e) {}
    };
    checkObj(globalThis, "globalThis", 0);
    checkObj(global, "global", 0);
    checkObj(core, "core", 0);
    results.push("7_ProcessSearch: " + (found.length ? found.join(",") : "NOT_FOUND"));
  } catch(e) {
    results.push("7_ProcessSearch: FAIL - " + e.message);
  }

  // Test 8: Check module.constructor
  try {
    const modCtor = module.constructor;
    const modCtorName = modCtor.name;
    results.push("8_ModuleCtor: " + modCtorName);
    // Try to access module internals
    const modKeys = Object.keys(module);
    results.push("8_ModuleKeys: " + modKeys.join(","));
  } catch(e) {
    results.push("8_ModuleCtor: FAIL - " + e.message);
  }

  // Test 9: exports object
  try {
    const expKeys = Object.keys(exports);
    results.push("9_Exports: " + expKeys.join(","));
  } catch(e) {
    results.push("9_Exports: FAIL - " + e.message);
  }

  // Test 10: require.cache
  try {
    const cache = require.cache;
    results.push("10_RequireCache: " + (cache ? Object.keys(cache).slice(0, 5).join(",") : "undefined"));
  } catch(e) {
    results.push("10_RequireCache: FAIL - " + e.message);
  }

  // Test 11: Try to access Error.prepareStackTrace
  try {
    const origPST = Error.prepareStackTrace;
    results.push("11_PrepareStackTrace: " + typeof origPST);
    // Try to override it
    let capturedStack = null;
    Error.prepareStackTrace = (err, stack) => {
      capturedStack = stack;
      return stack.map(s => s.toString()).join("\\n");
    };
    const e = new Error();
    const st = e.stack;
    Error.prepareStackTrace = origPST;
    results.push("11_CapturedStack: " + (capturedStack ? "YES len=" + capturedStack.length : "NO"));
  } catch(e) {
    results.push("11_PrepareStackTrace: FAIL - " + e.message);
  }

  // Test 12: Reflect and Proxy advanced
  try {
    const reflectKeys = Object.keys(Reflect);
    results.push("12_Reflect: " + reflectKeys.slice(0, 8).join(","));
  } catch(e) {
    results.push("12_Reflect: FAIL - " + e.message);
  }

  // Test 13: Symbol.for to find hidden symbols
  try {
    const nodeSymbols = ["nodejs.util.inspect.custom", "nodejs.rejection"];
    let foundSymbols = [];
    for (const s of nodeSymbols) {
      const sym = Symbol.for(s);
      foundSymbols.push(s + ":" + String(sym));
    }
    results.push("13_Symbols: " + foundSymbols.join(", "));
  } catch(e) {
    results.push("13_Symbols: FAIL - " + e.message);
  }

  // Test 14: setTimeout/setInterval
  try {
    results.push("14_Timers: setTimeout=" + typeof setTimeout + ", setInterval=" + typeof setInterval);
  } catch(e) {
    results.push("14_Timers: FAIL - " + e.message);
  }

  // Test 15: Promise internals
  try {
    const p = new Promise((resolve) => resolve(1));
    results.push("15_Promise: " + typeof p + ", ctor=" + p.constructor.name);
  } catch(e) {
    results.push("15_Promise: FAIL - " + e.message);
  }
}

SELECT
  '${JSON.stringify(results)}' as wasm_core_results
