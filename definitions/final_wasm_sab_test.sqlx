-- Final WebAssembly & SharedArrayBuffer Attack Vector Test
-- Tests if WASM or SAB can be used for sandbox escape

config {
  type: "view",
  name: "final_wasm_sab_test"
}

js {
  let r = [];

  // ============================================
  // SECTION 1: WebAssembly Capabilities
  // ============================================

  // 1.1: Check WASM availability and methods
  try {
    r.push('1.1_wasm: ' + typeof WebAssembly);
    r.push('1.1_wasm_keys: ' + Object.keys(WebAssembly).join(','));
    r.push('1.1_wasm_Module: ' + typeof WebAssembly.Module);
    r.push('1.1_wasm_Instance: ' + typeof WebAssembly.Instance);
    r.push('1.1_wasm_Memory: ' + typeof WebAssembly.Memory);
    r.push('1.1_wasm_Table: ' + typeof WebAssembly.Table);
    r.push('1.1_wasm_Global: ' + typeof WebAssembly.Global);
    r.push('1.1_wasm_compile: ' + typeof WebAssembly.compile);
    r.push('1.1_wasm_instantiate: ' + typeof WebAssembly.instantiate);
  } catch(e) { r.push('1.1_err: ' + e.message); }

  // 1.2: Try to compile and run simple WASM
  try {
    // Minimal WASM: (module (func (export "add") (param i32 i32) (result i32) local.get 0 local.get 1 i32.add))
    const wasmBytes = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01, 0x7f,
      0x03, 0x02, 0x01, 0x00,
      0x07, 0x07, 0x01, 0x03, 0x61, 0x64, 0x64, 0x00, 0x00,
      0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b
    ]);
    const module = new WebAssembly.Module(wasmBytes);
    const instance = new WebAssembly.Instance(module);
    r.push('1.2_wasm_run: add(2,3)=' + instance.exports.add(2, 3));
  } catch(e) { r.push('1.2_err: ' + e.message.substring(0,80)); }

  // 1.3: Test WASM Memory - can we access memory outside sandbox?
  try {
    const memory = new WebAssembly.Memory({ initial: 1, maximum: 10 });
    const view = new Uint8Array(memory.buffer);
    r.push('1.3_wasm_mem_size: ' + memory.buffer.byteLength);

    // Try to grow memory
    const oldPages = memory.grow(1);
    r.push('1.3_wasm_mem_grow: ' + oldPages + ' -> ' + (memory.buffer.byteLength / 65536) + ' pages');
  } catch(e) { r.push('1.3_err: ' + e.message.substring(0,80)); }

  // 1.4: Test WASM with imports (host function access)
  try {
    let hostCallLog = [];
    const imports = {
      env: {
        hostFunc: (x) => {
          hostCallLog.push(x);
          // Try to access host context
          return x * 2;
        },
        hostMemory: new WebAssembly.Memory({ initial: 1 })
      }
    };

    // WASM that calls imported function
    const wasmWithImport = new Uint8Array([
      0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x08, 0x02, 0x60, 0x01, 0x7f, 0x01, 0x7f, 0x60, 0x00, 0x01, 0x7f,
      0x02, 0x11, 0x01, 0x03, 0x65, 0x6e, 0x76, 0x08, 0x68, 0x6f, 0x73, 0x74,
      0x46, 0x75, 0x6e, 0x63, 0x00, 0x00,
      0x03, 0x02, 0x01, 0x01,
      0x07, 0x08, 0x01, 0x04, 0x63, 0x61, 0x6c, 0x6c, 0x00, 0x01,
      0x0a, 0x08, 0x01, 0x06, 0x00, 0x41, 0x15, 0x10, 0x00, 0x0b
    ]);

    const mod = new WebAssembly.Module(wasmWithImport);
    const inst = new WebAssembly.Instance(mod, imports);
    const result = inst.exports.call();
    r.push('1.4_wasm_import: result=' + result + ', calls=' + JSON.stringify(hostCallLog));
  } catch(e) { r.push('1.4_err: ' + e.message.substring(0,80)); }

  // 1.5: Check for streaming compilation (network access)
  try {
    r.push('1.5_compileStreaming: ' + typeof WebAssembly.compileStreaming);
    r.push('1.5_instantiateStreaming: ' + typeof WebAssembly.instantiateStreaming);
  } catch(e) { r.push('1.5_err: ' + e.message); }

  // ============================================
  // SECTION 2: SharedArrayBuffer
  // ============================================

  // 2.1: Check SAB availability
  try {
    r.push('2.1_SAB: ' + typeof SharedArrayBuffer);
    r.push('2.1_Atomics: ' + typeof Atomics);

    if (typeof SharedArrayBuffer !== 'undefined') {
      const sab = new SharedArrayBuffer(1024);
      r.push('2.1_SAB_created: size=' + sab.byteLength);

      const view = new Int32Array(sab);
      Atomics.store(view, 0, 42);
      r.push('2.1_Atomics_store: ' + Atomics.load(view, 0));

      // Check Atomics methods
      const atomicMethods = Object.getOwnPropertyNames(Atomics);
      r.push('2.1_Atomics_methods: ' + atomicMethods.join(','));
    } else {
      r.push('2.1_SAB: NOT_AVAILABLE');
    }
  } catch(e) { r.push('2.1_err: ' + e.message); }

  // 2.2: High precision timing (Spectre attack vector)
  try {
    if (typeof SharedArrayBuffer !== 'undefined') {
      const sab = new SharedArrayBuffer(4);
      const view = new Int32Array(sab);

      // Measure timing precision
      const iterations = 1000;
      const times = [];
      for (let i = 0; i < 10; i++) {
        const start = Atomics.load(view, 0);
        for (let j = 0; j < iterations; j++) {
          Atomics.add(view, 0, 1);
        }
        const end = Atomics.load(view, 0);
        times.push(end - start);
      }
      r.push('2.2_timing_test: ' + JSON.stringify(times.slice(0,5)));
    }
  } catch(e) { r.push('2.2_err: ' + e.message); }

  // ============================================
  // SECTION 3: DataView & TypedArrays
  // ============================================

  // 3.1: Check if we can access raw memory
  try {
    const buffer = new ArrayBuffer(1024);
    const view = new DataView(buffer);
    view.setInt32(0, 0x41414141, true);
    r.push('3.1_DataView: ' + view.getInt32(0, true).toString(16));

    // Check typed array constructors
    const typedArrays = [
      'Int8Array', 'Uint8Array', 'Uint8ClampedArray',
      'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array',
      'Float32Array', 'Float64Array', 'BigInt64Array', 'BigUint64Array'
    ];
    const available = typedArrays.filter(t => typeof globalThis[t] !== 'undefined');
    r.push('3.1_TypedArrays: ' + available.join(','));
  } catch(e) { r.push('3.1_err: ' + e.message); }

  // ============================================
  // SECTION 4: Cross-realm object access
  // ============================================

  // 4.1: Try to access objects from different realms
  try {
    // Check if we can find a different global context
    const frames = [
      globalThis,
      global,
      this,
      Function('return this')()
    ];

    let uniqueFrames = new Set();
    frames.forEach((f, i) => {
      if (f) uniqueFrames.add(f);
    });
    r.push('4.1_unique_contexts: ' + uniqueFrames.size);
  } catch(e) { r.push('4.1_err: ' + e.message); }

  // 4.2: Try to find vm module internals
  try {
    if (typeof vm !== 'undefined') {
      r.push('4.2_vm_compileModule: ' + typeof vm.compileModule);

      // Try to compile code that escapes
      const compiled = vm.compileModule('return { process, require, restricted_fs }');
      if (compiled) {
        const result = compiled();
        r.push('4.2_vm_result: ' + JSON.stringify(Object.keys(result || {})));
      }
    }
  } catch(e) { r.push('4.2_err: ' + e.message.substring(0,80)); }

  // ============================================
  // SECTION 5: Final Summary
  // ============================================
  r.push('5_SUMMARY: WASM=' + (typeof WebAssembly !== 'undefined') +
         ', SAB=' + (typeof SharedArrayBuffer !== 'undefined') +
         ', NO_WRITE=' + (typeof restricted_fs.writeFile === 'undefined') +
         ', NO_NET=' + (typeof fetch === 'undefined'));
}

SELECT '${JSON.stringify(r)}' as wasm_sab_results
