config { type: "view", name: "v8_exact_version" }

js {
  let v8Info = { probeTime: new Date().toISOString() };

  // Method 1: Try to get version from error stack
  try {
    const err = new Error('probe');
    v8Info.errorStack = err.stack;
  } catch(e) {}

  // Method 2: Check Function.prototype.toString for native code hints
  try {
    v8Info.functionToString = Function.prototype.toString.call(Array.prototype.at);
  } catch(e) {}

  // Method 3: Try to access v8 module if exposed
  try {
    if (typeof v8 !== 'undefined') v8Info.v8Module = Object.keys(v8);
  } catch(e) {}

  // Method 4: Check for version in global properties
  try {
    const globalKeys = Object.getOwnPropertyNames(globalThis);
    v8Info.versionRelatedKeys = globalKeys.filter(k =>
      k.toLowerCase().includes('version') ||
      k.toLowerCase().includes('v8')
    );
  } catch(e) {}

  // Method 5: Try Intl for engine info
  try {
    v8Info.intlLocales = Intl.DateTimeFormat.supportedLocalesOf(['en']).length;
    v8Info.intlCollator = typeof Intl.Collator === 'function';
    v8Info.intlSegmenter = typeof Intl.Segmenter === 'function'; // V8 9.2+
    v8Info.intlListFormat = typeof Intl.ListFormat === 'function'; // V8 7.2+
    v8Info.intlRelativeTimeFormat = typeof Intl.RelativeTimeFormat === 'function'; // V8 7.1+
    v8Info.intlDisplayNames = typeof Intl.DisplayNames === 'function'; // V8 8.1+
    v8Info.intlDurationFormat = typeof Intl.DurationFormat === 'function'; // V8 11.9+ (Stage 3)
  } catch(e) {}

  // Method 6: RegExp features for version inference
  try {
    v8Info.regexpHasIndices = 'hasIndices' in RegExp.prototype; // V8 9.0+
    v8Info.regexpMatchAll = typeof ''.matchAll === 'function'; // V8 7.3+
    v8Info.regexpDotAll = /./s.dotAll; // V8 6.2+
    v8Info.regexpNamedGroups = /(?<test>.)/.exec('a').groups !== undefined; // V8 6.4+
    v8Info.regexpLookbehind = (() => { try { new RegExp('(?<=a)b'); return true; } catch(e) { return false; }})();
    v8Info.regexpUnicodeSets = (() => { try { new RegExp('[\\p{L}]', 'v'); return true; } catch(e) { return false; }})(); // V8 11.2+
  } catch(e) {}

  // Method 7: Try to trigger version in error message
  try {
    eval('import.meta');
  } catch(e) {
    v8Info.importMetaError = e.message;
  }

  // Method 8: Check Iterator helpers (V8 12.2+)
  try {
    v8Info.iteratorHelpers = typeof [].values().map === 'function';
    v8Info.iteratorFrom = typeof Iterator !== 'undefined' && typeof Iterator.from === 'function';
  } catch(e) {
    v8Info.iteratorHelpers = false;
  }

  // Method 9: Check Set methods (V8 12.2+)
  try {
    v8Info.setUnion = typeof Set.prototype.union === 'function';
    v8Info.setIntersection = typeof Set.prototype.intersection === 'function';
  } catch(e) {}

  // Method 10: Check JSON modules / import assertions
  try {
    v8Info.importAttributes = (() => { try { eval('import("x", { with: { type: "json" } })'); return true; } catch(e) { return e.message.includes('Cannot find'); }})();
  } catch(e) {}

  // Refined version inference
  if (v8Info.setUnion) {
    v8Info.inferredV8 = "12.2+ (Set methods)";
  } else if (v8Info.iteratorHelpers) {
    v8Info.inferredV8 = "12.2+ (Iterator helpers)";
  } else if (v8Info.intlDurationFormat) {
    v8Info.inferredV8 = "11.9+ (Intl.DurationFormat)";
  } else if (v8Info.regexpUnicodeSets) {
    v8Info.inferredV8 = "11.2+ (RegExp v flag)";
  } else {
    v8Info.inferredV8 = "12.0+ (Promise.withResolvers, but no Set methods)";
  }
}

SELECT '${JSON.stringify(v8Info, null, 2)}' as v8_exact_version
